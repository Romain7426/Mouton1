
#define _GNU_SOURCE // pour avoir asprintf sous Debian qui est dans <stdio.h>

#include "lexer_for_c_language.h"

static int lexer_lexer_for_c_language_automaton_token_blank_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_blank_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_blank_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_blank_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_blank_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_comment_multilines_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_directive_mono_line_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_ident_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_ident_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_ident_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_ident_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_ident_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_zero_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_hex_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_bin_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_real_dec_simple_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_char_simple_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_char_simple_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_simple_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_simple_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_char_simple_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_char_simple_newline_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_char_empty_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_char_empty_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_empty_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_empty_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_char_empty_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_char_escape_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_char_escape_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_escape_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_escape_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_char_escape_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_char_wide_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_char_wide_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_wide_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_char_wide_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_char_wide_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_string_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_string_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_string_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_string_wide_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_string_wide_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_wide_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_wide_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_string_wide_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_open_par_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_open_par_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_par_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_par_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_open_par_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_close_par_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_close_par_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_par_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_par_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_close_par_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_open_bracket_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_close_bracket_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_open_brace_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_open_brace_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_brace_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_open_brace_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_open_brace_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_close_brace_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_close_brace_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_brace_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_close_brace_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_close_brace_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_comma_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_comma_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comma_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_comma_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_comma_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_point_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_point_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_point_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_point_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_point_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_arrow_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_semicolon_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_semicolon_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_semicolon_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_semicolon_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_semicolon_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_star_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_star_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_star_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_star_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_star_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_plus_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_minus_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_rdiv_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_tilde_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_hat_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_percent_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_bang_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_different_huh_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_inf_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_sup_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_lshift_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_rshift_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_huh_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_colon_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_ellipsis_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_star_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_mot_reconnu_huh(const char * mot);
static int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_initial_get(void);
static int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_puits_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_final_huh(const int etat);
static int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre);
static int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_mot_reconnu_huh(const char * mot);












#include <string.h>
#include <stdlib.h>
#include <assert.h>


#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>


static char * lexer_lexer_for_c_language_token_type_strcopy(const char * str);
char * lexer_lexer_for_c_language_token_type_strcopy(const char * str) {
  const size_t len = strlen(str);
  const size_t len_octet = (len+1) * (sizeof(char));
  char * retour;
  retour = (char *) malloc(len_octet);
  memcpy(retour, str, len_octet);
  return retour;
}


static char * lexer_lexer_for_c_language_token_type_int_string(int n);
char * lexer_lexer_for_c_language_token_type_int_string(int n) {
  char * retour;
  asprintf(&retour, "%d", n);
  return retour;
}


static char * lexer_lexer_for_c_language_token_type_strconcat2(const char * const str1, const char * const str2);
char * lexer_lexer_for_c_language_token_type_strconcat2(const char * const str1, const char * const str2) {
  const size_t len = strlen(str1) + strlen(str2);
  return strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2);
}


static char * lexer_lexer_for_c_language_token_type_strconcat3(const char * const str1, const char * const str2, const char * const str3);
char * lexer_lexer_for_c_language_token_type_strconcat3(const char * const str1, const char * const str2, const char * const str3) {
  const size_t len = strlen(str1) + strlen(str2) + strlen(str3);
  return strcat(strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2), str3);
}


static void lexer_lexer_for_c_language_token_type_stradd2(char * * str0, const char * str1);
void lexer_lexer_for_c_language_token_type_stradd2(char * * str0, const char * str1) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_type_strconcat2(*str0, str1);
  free(*str0);
  *str0 = temp;
}


static void lexer_lexer_for_c_language_token_type_stradd3(char * * str0, const char * str1, const char * str2);
void lexer_lexer_for_c_language_token_type_stradd3(char * * str0, const char * str1, const char * str2) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_type_strconcat3(*str0, str1, str2);
  free(*str0);
  *str0 = temp;
}


static char * lexer_lexer_for_c_language_token_type_substring(const char * str, unsigned int debut, unsigned int fin);
char * lexer_lexer_for_c_language_token_type_substring(const char * str, unsigned int debut, unsigned int fin) {
  size_t len;
  size_t taille_octet;
  char * retour;
  assert(debut <= fin);
  len = fin - debut;
  taille_octet = (len + 1) * (sizeof (char));
  retour = (char *) malloc(taille_octet);
  memcpy(retour, str + debut, taille_octet);
  retour[len] = '\0';
  return retour;
}







static lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type_int_to_enum(const int n);
lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type_int_to_enum(const int n) {
  switch (n) {
    default: assert(0 != 0); return -1; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BLANK: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BLANK; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_MULTILINES: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_MULTILINES; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_ONELINE_CPP: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_ONELINE_CPP; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MONO_LINE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MONO_LINE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MULTI_LINES: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MULTI_LINES; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_IDENT: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_IDENT; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_ZERO: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_ZERO; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC_V2: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC_V2; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_HEX: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_HEX; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_BIN: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_BIN; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VCC: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VCC; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VC: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VC; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_SIMPLE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_SIMPLE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_WITH_EXP: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_WITH_EXP; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_HEX_WITH_EXP: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_HEX_WITH_EXP; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE_NEWLINE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE_NEWLINE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_EMPTY: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_EMPTY; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_ESCAPE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_ESCAPE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_WIDE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_WIDE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_ENDED_BY_NEWLINE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_ENDED_BY_NEWLINE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE_ENDED_BY_NEWLINE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE_ENDED_BY_NEWLINE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_PAR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_PAR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_PAR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_PAR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACKET: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACKET; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACKET: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACKET; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACE: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACE; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMA: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMA; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_POINT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_POINT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ARROW_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ARROW_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SEMICOLON: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SEMICOLON; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STAR_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STAR_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RDIV_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RDIV_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_TILDE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_TILDE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PERLUETE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PERLUETE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PERLUETE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PERLUETE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PIPE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PIPE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PIPE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PIPE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_EQUAL_HUH_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_EQUAL_HUH_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HAT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HAT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PERCENT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PERCENT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BANG_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BANG_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIFFERENT_HUH_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIFFERENT_HUH_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OR_EQUAL_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OR_EQUAL_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OR_EQUAL_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OR_EQUAL_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_PLUS_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_PLUS_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_MINUS_OPERARTOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_MINUS_OPERARTOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_LSHIFT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_LSHIFT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RSHIFT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RSHIFT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HUH_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HUH_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COLON_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COLON_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ELLIPSIS: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ELLIPSIS; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_STAR_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_STAR_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RDIV_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RDIV_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERCENT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERCENT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PLUS_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PLUS_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_MINUS_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_MINUS_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_LSHIFT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_LSHIFT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RSHIFT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RSHIFT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERLUETE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERLUETE_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_HAT_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_HAT_OPERATOR; break;
    case LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PIPE_OPERATOR: return LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PIPE_OPERATOR; break;
  };
  assert(0 != 0);
  return -1;
};

lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type_make(void) {
  assert(0 != 0);
  return 0;
};

void lexer_lexer_for_c_language_token_type_free(lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type) {
  return;
};

lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type_copy(const lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type) {
  return lexer_lexer_for_c_language_token_type;
};

const char * lexer_lexer_for_c_language_token_type_string_tab[71] = {
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BLANK",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_MULTILINES",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_ONELINE_CPP",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MONO_LINE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MULTI_LINES",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_IDENT",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_ZERO",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC_V2",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_HEX",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_BIN",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VCC",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VC",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_SIMPLE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_WITH_EXP",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_HEX_WITH_EXP",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE_NEWLINE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_EMPTY",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_ESCAPE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_WIDE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_ENDED_BY_NEWLINE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE_ENDED_BY_NEWLINE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_PAR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_PAR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACKET",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACKET",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACE",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMA",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_POINT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ARROW_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SEMICOLON",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STAR_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RDIV_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_TILDE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PERLUETE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PERLUETE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PIPE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PIPE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_EQUAL_HUH_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HAT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PERCENT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BANG_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIFFERENT_HUH_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OR_EQUAL_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OR_EQUAL_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_PLUS_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_MINUS_OPERARTOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_LSHIFT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RSHIFT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HUH_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COLON_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ELLIPSIS",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_STAR_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RDIV_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERCENT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PLUS_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_MINUS_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_LSHIFT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RSHIFT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERLUETE_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_HAT_OPERATOR",
  "LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PIPE_OPERATOR"
};

const char * lexer_lexer_for_c_language_token_type_string_const(const lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type) {
  return lexer_lexer_for_c_language_token_type_string_tab[lexer_lexer_for_c_language_token_type];
};

char * lexer_lexer_for_c_language_token_type_string(const lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type) {
  return lexer_lexer_for_c_language_token_type_strcopy(lexer_lexer_for_c_language_token_type_string_tab[lexer_lexer_for_c_language_token_type]);
};

int lexer_lexer_for_c_language_token_type_equal(const lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type1, const lexer_lexer_for_c_language_token_type_t lexer_lexer_for_c_language_token_type2) {
  return (lexer_lexer_for_c_language_token_type1 == lexer_lexer_for_c_language_token_type2);
};



#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>


#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>


static char * lexer_lexer_for_c_language_token_strcopy(const char * str);
char * lexer_lexer_for_c_language_token_strcopy(const char * str) {
  const size_t len = strlen(str);
  const size_t len_octet = (len+1) * (sizeof(char));
  char * retour;
  retour = (char *) malloc(len_octet);
  memcpy(retour, str, len_octet);
  return retour;
}


static char * lexer_lexer_for_c_language_token_int_string(int n);
char * lexer_lexer_for_c_language_token_int_string(int n) {
  char * retour;
  asprintf(&retour, "%d", n);
  return retour;
}


static char * lexer_lexer_for_c_language_token_strconcat2(const char * const str1, const char * const str2);
char * lexer_lexer_for_c_language_token_strconcat2(const char * const str1, const char * const str2) {
  const size_t len = strlen(str1) + strlen(str2);
  return strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2);
}


static char * lexer_lexer_for_c_language_token_strconcat3(const char * const str1, const char * const str2, const char * const str3);
char * lexer_lexer_for_c_language_token_strconcat3(const char * const str1, const char * const str2, const char * const str3) {
  const size_t len = strlen(str1) + strlen(str2) + strlen(str3);
  return strcat(strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2), str3);
}


static void lexer_lexer_for_c_language_token_stradd2(char * * str0, const char * str1);
void lexer_lexer_for_c_language_token_stradd2(char * * str0, const char * str1) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_strconcat2(*str0, str1);
  free(*str0);
  *str0 = temp;
}


static void lexer_lexer_for_c_language_token_stradd3(char * * str0, const char * str1, const char * str2);
void lexer_lexer_for_c_language_token_stradd3(char * * str0, const char * str1, const char * str2) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_strconcat3(*str0, str1, str2);
  free(*str0);
  *str0 = temp;
}


static char * lexer_lexer_for_c_language_token_substring(const char * str, unsigned int debut, unsigned int fin);
char * lexer_lexer_for_c_language_token_substring(const char * str, unsigned int debut, unsigned int fin) {
  size_t len;
  size_t taille_octet;
  char * retour;
  assert(debut <= fin);
  len = fin - debut;
  taille_octet = (len + 1) * (sizeof (char));
  retour = (char *) malloc(taille_octet);
  memcpy(retour, str + debut, taille_octet);
  retour[len] = '\0';
  return retour;
}







static lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_allouer(void);


lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_allouer(void) {
  return (lexer_lexer_for_c_language_token_t *) malloc((sizeof (lexer_lexer_for_c_language_token_t)));
};


lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_make(const lexer_lexer_for_c_language_token_type_t type, const char * value) {
  return lexer_lexer_for_c_language_token_make_nocopy(type, lexer_lexer_for_c_language_token_strcopy(value));
};


lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_make_nocopy(lexer_lexer_for_c_language_token_type_t type, char * value) {
  lexer_lexer_for_c_language_token_t * retour;

  retour = lexer_lexer_for_c_language_token_allouer();

  retour -> type = type;
  retour -> value = value;
  
  return retour;
};


void lexer_lexer_for_c_language_token_free(lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token) {
  if (lexer_lexer_for_c_language_token == NULL) return;
  free(lexer_lexer_for_c_language_token -> value);
  free(lexer_lexer_for_c_language_token);
  return;
};


lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_copy(const lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token) {
  if (NULL == lexer_lexer_for_c_language_token) return NULL;
  return lexer_lexer_for_c_language_token_make(lexer_lexer_for_c_language_token -> type, lexer_lexer_for_c_language_token -> value);
};


char * lexer_lexer_for_c_language_token_string(const lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token) {
  if (lexer_lexer_for_c_language_token == NULL) return lexer_lexer_for_c_language_token_strcopy("NULL");
  
  char * retour;
  char * temp;
  
  retour = lexer_lexer_for_c_language_token_strcopy("");
  
  lexer_lexer_for_c_language_token_stradd2(&retour, "struct lexer_lexer_for_c_language_token_t [");
  
  temp = lexer_lexer_for_c_language_token_type_string(lexer_lexer_for_c_language_token -> type);
  lexer_lexer_for_c_language_token_stradd3(&retour, "type = ", temp);
  free(temp);
  
  lexer_lexer_for_c_language_token_stradd2(&retour, ", ");
  
  temp = lexer_lexer_for_c_language_token_strcopy(lexer_lexer_for_c_language_token -> value);
  lexer_lexer_for_c_language_token_stradd3(&retour, "value = ", temp);
  free(temp);
  
  
  lexer_lexer_for_c_language_token_stradd2(&retour, "]");
  
  return retour;
};


int lexer_lexer_for_c_language_token_equal(const lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token1, const lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token2) {
  if (lexer_lexer_for_c_language_token1 == lexer_lexer_for_c_language_token2) return (0 == 0);
  if (lexer_lexer_for_c_language_token1 == NULL) return (0 != 0);
  if (lexer_lexer_for_c_language_token2 == NULL) return (0 != 0);
  
  return ((lexer_lexer_for_c_language_token1 -> type == lexer_lexer_for_c_language_token2 -> type) && (0 == strcmp(lexer_lexer_for_c_language_token1 -> value, lexer_lexer_for_c_language_token2 -> value)));
};


#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>


static char * lexer_lexer_for_c_language_token_liste_strcopy(const char * str);
char * lexer_lexer_for_c_language_token_liste_strcopy(const char * str) {
  const size_t len = strlen(str);
  const size_t len_octet = (len+1) * (sizeof(char));
  char * retour;
  retour = (char *) malloc(len_octet);
  memcpy(retour, str, len_octet);
  return retour;
}


static char * lexer_lexer_for_c_language_token_liste_int_string(int n);
char * lexer_lexer_for_c_language_token_liste_int_string(int n) {
  char * retour;
  asprintf(&retour, "%d", n);
  return retour;
}


static char * lexer_lexer_for_c_language_token_liste_strconcat2(const char * const str1, const char * const str2);
char * lexer_lexer_for_c_language_token_liste_strconcat2(const char * const str1, const char * const str2) {
  const size_t len = strlen(str1) + strlen(str2);
  return strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2);
}


static char * lexer_lexer_for_c_language_token_liste_strconcat3(const char * const str1, const char * const str2, const char * const str3);
char * lexer_lexer_for_c_language_token_liste_strconcat3(const char * const str1, const char * const str2, const char * const str3) {
  const size_t len = strlen(str1) + strlen(str2) + strlen(str3);
  return strcat(strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2), str3);
}


static void lexer_lexer_for_c_language_token_liste_stradd2(char * * str0, const char * str1);
void lexer_lexer_for_c_language_token_liste_stradd2(char * * str0, const char * str1) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_liste_strconcat2(*str0, str1);
  free(*str0);
  *str0 = temp;
}


static void lexer_lexer_for_c_language_token_liste_stradd3(char * * str0, const char * str1, const char * str2);
void lexer_lexer_for_c_language_token_liste_stradd3(char * * str0, const char * str1, const char * str2) {
  char * temp;
  temp = lexer_lexer_for_c_language_token_liste_strconcat3(*str0, str1, str2);
  free(*str0);
  *str0 = temp;
}


static char * lexer_lexer_for_c_language_token_liste_substring(const char * str, unsigned int debut, unsigned int fin);
char * lexer_lexer_for_c_language_token_liste_substring(const char * str, unsigned int debut, unsigned int fin) {
  size_t len;
  size_t taille_octet;
  char * retour;
  assert(debut <= fin);
  len = fin - debut;
  taille_octet = (len + 1) * (sizeof (char));
  retour = (char *) malloc(taille_octet);
  memcpy(retour, str + debut, taille_octet);
  retour[len] = '\0';
  return retour;
}









static lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_allouer(void);


static void lexer_lexer_for_c_language_token_liste_reverse_aux(const lexer_lexer_for_c_language_token_liste_t * l, lexer_lexer_for_c_language_token_liste_t * * accu);



lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_vide(void) {
  return NULL;
}

int lexer_lexer_for_c_language_token_liste_vide_huh(const lexer_lexer_for_c_language_token_liste_t * l) {
  return (NULL == l);
}

lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_allouer(void) {
  return (lexer_lexer_for_c_language_token_liste_t *) malloc(sizeof (lexer_lexer_for_c_language_token_liste_t));
}

lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_cons(const lexer_lexer_for_c_language_token_t * a, const lexer_lexer_for_c_language_token_liste_t * l) {
  return lexer_lexer_for_c_language_token_liste_cons_nocopy(lexer_lexer_for_c_language_token_copy(a), lexer_lexer_for_c_language_token_liste_copy(l));
}

lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_cons_nocopy(lexer_lexer_for_c_language_token_t * a, lexer_lexer_for_c_language_token_liste_t * l) {
  lexer_lexer_for_c_language_token_liste_t * retour;
  retour = lexer_lexer_for_c_language_token_liste_allouer();
  retour -> car = a;
  retour -> cdr = l;
  return retour;
}

void lexer_lexer_for_c_language_token_liste_free(lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) return;
  lexer_lexer_for_c_language_token_free(l -> car);
  lexer_lexer_for_c_language_token_liste_free(l -> cdr);
  free(l);
}

void lexer_lexer_for_c_language_token_liste_free_nocopy(lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) return;
  lexer_lexer_for_c_language_token_liste_free_nocopy(l -> cdr);
  free(l);
}

lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_copy(const lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) 
    return NULL;
  
  return lexer_lexer_for_c_language_token_liste_cons(l -> car, l -> cdr);
}

int lexer_lexer_for_c_language_token_liste_longueur(const lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) {
    return 0;
  }
  
  return 1 + lexer_lexer_for_c_language_token_liste_longueur(l -> cdr);
}


#if 0
lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_vlist(int n, va_list args) {
  int i;
  lexer_lexer_for_c_language_token_liste_t * retour;
  lexer_lexer_for_c_language_token_liste_element_t temp;

  retour = lexer_lexer_for_c_language_token_liste_vide();
  
  for (i = 0; i < n; i++) {
    temp = va_arg(args, lexer_lexer_for_c_language_token_liste_element_t);
    retour = lexer_lexer_for_c_language_token_liste_cons_element(temp, retour);
  }

  lexer_lexer_for_c_language_token_liste_reverse_surplace(&retour);

  return retour;
}

lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_list(int n, ...) {
  va_list args;
  lexer_lexer_for_c_language_token_liste_t * retour;

  va_start(args, n);
  retour = lexer_lexer_for_c_language_token_liste_vlist(n, args);
  va_end(args);

  return retour;
}
#endif


int lexer_lexer_for_c_language_token_liste_equal(const lexer_lexer_for_c_language_token_liste_t * l1, const lexer_lexer_for_c_language_token_liste_t * l2) {
  int b1;
  int b2;
  int b3;

  b1 = lexer_lexer_for_c_language_token_liste_vide_huh(l1);
  b2 = lexer_lexer_for_c_language_token_liste_vide_huh(l2);
 
  if (b1) {
    return b2;
  }

  if (b2) {
    return (0 != 0);
  }

  b3 = lexer_lexer_for_c_language_token_equal(l1 -> car, l2 -> car);
  if (b3) {
    return lexer_lexer_for_c_language_token_liste_equal(l1 -> cdr, l2 -> cdr);
  }
  else {
    return (0 != 0);
  }

  assert(0 != 0);
  return (0 != 0);
}



int lexer_lexer_for_c_language_token_liste_member(const lexer_lexer_for_c_language_token_t * a, const lexer_lexer_for_c_language_token_liste_t * liste) {
  int b;

  b = lexer_lexer_for_c_language_token_liste_vide_huh(liste);

  if (b) return (0 != 0);

  b = lexer_lexer_for_c_language_token_equal(a, liste -> car);

  if (b) return (0 == 0);

  return lexer_lexer_for_c_language_token_liste_member(a, liste -> cdr);
}


int lexer_lexer_for_c_language_token_liste_member_iteratif(const lexer_lexer_for_c_language_token_t * a, const lexer_lexer_for_c_language_token_liste_t * liste) {
  while (!(lexer_lexer_for_c_language_token_liste_vide_huh(liste))) {
    if (lexer_lexer_for_c_language_token_equal(a, liste -> car)) return (0 == 0); 

    liste = liste -> cdr;
  }

  return (0 != 0);
}
 
 
lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_liste_pop(lexer_lexer_for_c_language_token_liste_t * * l) {
  assert(l != NULL);
  assert(*l != NULL);

  lexer_lexer_for_c_language_token_t * a;
  lexer_lexer_for_c_language_token_liste_t * p;

  a = (*l) -> car;
  p = (*l) -> cdr;
  
  free(*l);

  *l = p;

  return a;
}


lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_map(lexer_lexer_for_c_language_token_t * (* f)(const lexer_lexer_for_c_language_token_t *), const lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) return NULL;

  return lexer_lexer_for_c_language_token_liste_cons_nocopy(f(l -> car), lexer_lexer_for_c_language_token_liste_map(f, l -> cdr));
}


lexer_lexer_for_c_language_token_t * lexer_lexer_for_c_language_token_liste_fold(lexer_lexer_for_c_language_token_t * (* f)(const lexer_lexer_for_c_language_token_t *, const lexer_lexer_for_c_language_token_t *), const lexer_lexer_for_c_language_token_t * a, const lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) return lexer_lexer_for_c_language_token_copy(a);
  
  return f(l -> car, lexer_lexer_for_c_language_token_liste_fold(f, a, l -> cdr));
}


char * lexer_lexer_for_c_language_token_liste_string(const lexer_lexer_for_c_language_token_liste_t * l) {
  char * retour;
  int n;
  int i;
  char * prec;
  char * str;

  n = lexer_lexer_for_c_language_token_liste_longueur(l);

  if (n == 0) {
    const char * const u = "list []";
    //retour = strcopy("list []");
    return strcpy(malloc(strlen(u)+1), u);
  }

  retour = lexer_lexer_for_c_language_token_liste_strcopy("list [");

  assert(n >= 1);
  for (i = 0; i < n - 1; i++) {
    prec = retour;
    str = lexer_lexer_for_c_language_token_string(l -> car);
    retour = lexer_lexer_for_c_language_token_liste_strconcat3(prec, str, ", ");
    free(str);
    free(prec);
    l = l -> cdr;
  }

  prec = retour;

  str = lexer_lexer_for_c_language_token_string(l -> car);
  retour = lexer_lexer_for_c_language_token_liste_strconcat2(prec, str);
  free(str);
  free(prec);
  prec = retour;

  retour = lexer_lexer_for_c_language_token_liste_strconcat2(prec, "]");
  free(prec);

  return retour;
}





lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_reverse(const lexer_lexer_for_c_language_token_liste_t * l) {
  lexer_lexer_for_c_language_token_liste_t * retour;

  retour = NULL;
  lexer_lexer_for_c_language_token_liste_reverse_aux(l, &retour);

  return retour;
}

void lexer_lexer_for_c_language_token_liste_reverse_aux(const lexer_lexer_for_c_language_token_liste_t * l, lexer_lexer_for_c_language_token_liste_t * * accu) {
  if (l == NULL) {
    return;
  }

  *accu = lexer_lexer_for_c_language_token_liste_cons_nocopy(lexer_lexer_for_c_language_token_copy(l -> car), *accu);

  lexer_lexer_for_c_language_token_liste_reverse_aux(l -> cdr, accu);
}


void lexer_lexer_for_c_language_token_liste_reverse_surplace(lexer_lexer_for_c_language_token_liste_t * * liste) {
  assert(liste != NULL);
  lexer_lexer_for_c_language_token_liste_t * precedent;
  lexer_lexer_for_c_language_token_liste_t * courant;
  lexer_lexer_for_c_language_token_liste_t * suivant;

  if (lexer_lexer_for_c_language_token_liste_vide_huh(*liste)) return;

  precedent = lexer_lexer_for_c_language_token_liste_vide();
  courant = *liste;
  suivant = courant -> cdr;

  while (!(lexer_lexer_for_c_language_token_liste_vide_huh(suivant))) {
    courant -> cdr = precedent;

    precedent = courant;
    courant = suivant;
    suivant = suivant -> cdr;
  }

  courant -> cdr = precedent;

  *liste = courant;
}



lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_token_liste_append(const lexer_lexer_for_c_language_token_liste_t * l, const lexer_lexer_for_c_language_token_liste_t * m) {
  if (l == NULL) return lexer_lexer_for_c_language_token_liste_copy(m);

  return lexer_lexer_for_c_language_token_liste_cons_nocopy(lexer_lexer_for_c_language_token_copy(l -> car), lexer_lexer_for_c_language_token_liste_append(l -> cdr, m));
}

void lexer_lexer_for_c_language_token_liste_append_nocopy(lexer_lexer_for_c_language_token_liste_t * * l, lexer_lexer_for_c_language_token_liste_t * m) {
  if (*l == NULL) {
    *l = m;
    return;
  }
  
  lexer_lexer_for_c_language_token_liste_append_nocopy(&((*l) -> cdr), m);
}


int lexer_lexer_for_c_language_token_liste_count(const lexer_lexer_for_c_language_token_t * a, const lexer_lexer_for_c_language_token_liste_t * l) {
  if (l == NULL) return 0;
  int s, t;
  s = (lexer_lexer_for_c_language_token_equal(a, l->car)) ? 1 : 0;
  t = lexer_lexer_for_c_language_token_liste_count(a, l -> cdr);
  return s + t;
}

int lexer_lexer_for_c_language_automaton_token_blank_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_blank_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_blank_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_blank_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 9: etat_suivant = 1; break; // case '\t':
        case 10: etat_suivant = 1; break; // case '\n':
        case 11: etat_suivant = 1; break; // case '\v':
        case 12: etat_suivant = 1; break; // case '\f':
        case 13: etat_suivant = 1; break; // case '\r':
        case 32: etat_suivant = 1; break; // case ' ':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 9: etat_suivant = 1; break; // case '\t':
        case 10: etat_suivant = 1; break; // case '\n':
        case 11: etat_suivant = 1; break; // case '\v':
        case 12: etat_suivant = 1; break; // case '\f':
        case 13: etat_suivant = 1; break; // case '\r':
        case 32: etat_suivant = 1; break; // case ' ':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_blank_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_blank_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_blank_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_blank_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_initial_get(void) {
  return 5;
}


int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 42: etat_suivant = 2; break; // case '*':
        case 47: etat_suivant = 1; break; // case '/':
        default: etat_suivant = 3; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 42: etat_suivant = 2; break; // case '*':
        default: etat_suivant = 3; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 42: etat_suivant = 3; break; // case '*':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 47: etat_suivant = 4; break; // case '/':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_comment_multilines_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 47: etat_suivant = 2; break; // case '/':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 47: etat_suivant = 3; break; // case '/':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 35: etat_suivant = 2; break; // case '#':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_directive_mono_line_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 == 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        case 92: etat_suivant = 5; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 35: etat_suivant = 2; break; // case '#':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        case 92: etat_suivant = 5; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 10: etat_suivant = 4; break; // case '\n':
        case 92: etat_suivant = 5; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_directive_multi_lines_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_ident_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_ident_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_ident_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_ident_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        case 56: etat_suivant = 1; break; // case '8':
        case 57: etat_suivant = 1; break; // case '9':
        case 65: etat_suivant = 1; break; // case 'A':
        case 66: etat_suivant = 1; break; // case 'B':
        case 67: etat_suivant = 1; break; // case 'C':
        case 68: etat_suivant = 1; break; // case 'D':
        case 69: etat_suivant = 1; break; // case 'E':
        case 70: etat_suivant = 1; break; // case 'F':
        case 71: etat_suivant = 1; break; // case 'G':
        case 72: etat_suivant = 1; break; // case 'H':
        case 73: etat_suivant = 1; break; // case 'I':
        case 74: etat_suivant = 1; break; // case 'J':
        case 75: etat_suivant = 1; break; // case 'K':
        case 76: etat_suivant = 1; break; // case 'L':
        case 77: etat_suivant = 1; break; // case 'M':
        case 78: etat_suivant = 1; break; // case 'N':
        case 79: etat_suivant = 1; break; // case 'O':
        case 80: etat_suivant = 1; break; // case 'P':
        case 81: etat_suivant = 1; break; // case 'Q':
        case 82: etat_suivant = 1; break; // case 'R':
        case 83: etat_suivant = 1; break; // case 'S':
        case 84: etat_suivant = 1; break; // case 'T':
        case 85: etat_suivant = 1; break; // case 'U':
        case 86: etat_suivant = 1; break; // case 'V':
        case 87: etat_suivant = 1; break; // case 'W':
        case 88: etat_suivant = 1; break; // case 'X':
        case 89: etat_suivant = 1; break; // case 'Y':
        case 90: etat_suivant = 1; break; // case 'Z':
        case 95: etat_suivant = 1; break; // case '_':
        case 97: etat_suivant = 1; break; // case 'a':
        case 98: etat_suivant = 1; break; // case 'b':
        case 99: etat_suivant = 1; break; // case 'c':
        case 100: etat_suivant = 1; break; // case 'd':
        case 101: etat_suivant = 1; break; // case 'e':
        case 102: etat_suivant = 1; break; // case 'f':
        case 103: etat_suivant = 1; break; // case 'g':
        case 104: etat_suivant = 1; break; // case 'h':
        case 105: etat_suivant = 1; break; // case 'i':
        case 106: etat_suivant = 1; break; // case 'j':
        case 107: etat_suivant = 1; break; // case 'k':
        case 108: etat_suivant = 1; break; // case 'l':
        case 109: etat_suivant = 1; break; // case 'm':
        case 110: etat_suivant = 1; break; // case 'n':
        case 111: etat_suivant = 1; break; // case 'o':
        case 112: etat_suivant = 1; break; // case 'p':
        case 113: etat_suivant = 1; break; // case 'q':
        case 114: etat_suivant = 1; break; // case 'r':
        case 115: etat_suivant = 1; break; // case 's':
        case 116: etat_suivant = 1; break; // case 't':
        case 117: etat_suivant = 1; break; // case 'u':
        case 118: etat_suivant = 1; break; // case 'v':
        case 119: etat_suivant = 1; break; // case 'w':
        case 120: etat_suivant = 1; break; // case 'x':
        case 121: etat_suivant = 1; break; // case 'y':
        case 122: etat_suivant = 1; break; // case 'z':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 65: etat_suivant = 1; break; // case 'A':
        case 66: etat_suivant = 1; break; // case 'B':
        case 67: etat_suivant = 1; break; // case 'C':
        case 68: etat_suivant = 1; break; // case 'D':
        case 69: etat_suivant = 1; break; // case 'E':
        case 70: etat_suivant = 1; break; // case 'F':
        case 71: etat_suivant = 1; break; // case 'G':
        case 72: etat_suivant = 1; break; // case 'H':
        case 73: etat_suivant = 1; break; // case 'I':
        case 74: etat_suivant = 1; break; // case 'J':
        case 75: etat_suivant = 1; break; // case 'K':
        case 76: etat_suivant = 1; break; // case 'L':
        case 77: etat_suivant = 1; break; // case 'M':
        case 78: etat_suivant = 1; break; // case 'N':
        case 79: etat_suivant = 1; break; // case 'O':
        case 80: etat_suivant = 1; break; // case 'P':
        case 81: etat_suivant = 1; break; // case 'Q':
        case 82: etat_suivant = 1; break; // case 'R':
        case 83: etat_suivant = 1; break; // case 'S':
        case 84: etat_suivant = 1; break; // case 'T':
        case 85: etat_suivant = 1; break; // case 'U':
        case 86: etat_suivant = 1; break; // case 'V':
        case 87: etat_suivant = 1; break; // case 'W':
        case 88: etat_suivant = 1; break; // case 'X':
        case 89: etat_suivant = 1; break; // case 'Y':
        case 90: etat_suivant = 1; break; // case 'Z':
        case 95: etat_suivant = 1; break; // case '_':
        case 97: etat_suivant = 1; break; // case 'a':
        case 98: etat_suivant = 1; break; // case 'b':
        case 99: etat_suivant = 1; break; // case 'c':
        case 100: etat_suivant = 1; break; // case 'd':
        case 101: etat_suivant = 1; break; // case 'e':
        case 102: etat_suivant = 1; break; // case 'f':
        case 103: etat_suivant = 1; break; // case 'g':
        case 104: etat_suivant = 1; break; // case 'h':
        case 105: etat_suivant = 1; break; // case 'i':
        case 106: etat_suivant = 1; break; // case 'j':
        case 107: etat_suivant = 1; break; // case 'k':
        case 108: etat_suivant = 1; break; // case 'l':
        case 109: etat_suivant = 1; break; // case 'm':
        case 110: etat_suivant = 1; break; // case 'n':
        case 111: etat_suivant = 1; break; // case 'o':
        case 112: etat_suivant = 1; break; // case 'p':
        case 113: etat_suivant = 1; break; // case 'q':
        case 114: etat_suivant = 1; break; // case 'r':
        case 115: etat_suivant = 1; break; // case 's':
        case 116: etat_suivant = 1; break; // case 't':
        case 117: etat_suivant = 1; break; // case 'u':
        case 118: etat_suivant = 1; break; // case 'v':
        case 119: etat_suivant = 1; break; // case 'w':
        case 120: etat_suivant = 1; break; // case 'x':
        case 121: etat_suivant = 1; break; // case 'y':
        case 122: etat_suivant = 1; break; // case 'z':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_ident_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_ident_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_ident_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_ident_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_zero_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_zero_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_zero_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_zero_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_zero_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 == 0); break;
    case 4: etat_final_huh = (0 == 0); break;
    case 5: etat_final_huh = (0 == 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        case 76: etat_suivant = 4; break; // case 'L':
        case 85: etat_suivant = 5; break; // case 'U':
        case 108: etat_suivant = 4; break; // case 'l':
        case 117: etat_suivant = 5; break; // case 'u':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 76: etat_suivant = 1; break; // case 'L':
        case 108: etat_suivant = 1; break; // case 'l':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 76: etat_suivant = 4; break; // case 'L':
        case 108: etat_suivant = 4; break; // case 'l':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_dec_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_dec_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_dec_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        case 56: etat_suivant = 1; break; // case '8':
        case 57: etat_suivant = 1; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        case 56: etat_suivant = 1; break; // case '8':
        case 57: etat_suivant = 1; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 68: etat_suivant = 2; break; // case 'D':
        case 100: etat_suivant = 2; break; // case 'd':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_dec_v2_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_hex_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        case 56: etat_suivant = 1; break; // case '8':
        case 57: etat_suivant = 1; break; // case '9':
        case 65: etat_suivant = 1; break; // case 'A':
        case 66: etat_suivant = 1; break; // case 'B':
        case 67: etat_suivant = 1; break; // case 'C':
        case 68: etat_suivant = 1; break; // case 'D':
        case 69: etat_suivant = 1; break; // case 'E':
        case 70: etat_suivant = 1; break; // case 'F':
        case 97: etat_suivant = 1; break; // case 'a':
        case 98: etat_suivant = 1; break; // case 'b':
        case 99: etat_suivant = 1; break; // case 'c':
        case 100: etat_suivant = 1; break; // case 'd':
        case 101: etat_suivant = 1; break; // case 'e':
        case 102: etat_suivant = 1; break; // case 'f':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        case 56: etat_suivant = 1; break; // case '8':
        case 57: etat_suivant = 1; break; // case '9':
        case 65: etat_suivant = 1; break; // case 'A':
        case 66: etat_suivant = 1; break; // case 'B':
        case 67: etat_suivant = 1; break; // case 'C':
        case 68: etat_suivant = 1; break; // case 'D':
        case 69: etat_suivant = 1; break; // case 'E':
        case 70: etat_suivant = 1; break; // case 'F':
        case 97: etat_suivant = 1; break; // case 'a':
        case 98: etat_suivant = 1; break; // case 'b':
        case 99: etat_suivant = 1; break; // case 'c':
        case 100: etat_suivant = 1; break; // case 'd':
        case 101: etat_suivant = 1; break; // case 'e':
        case 102: etat_suivant = 1; break; // case 'f':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 88: etat_suivant = 2; break; // case 'X':
        case 120: etat_suivant = 2; break; // case 'x':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_hex_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_hex_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_hex_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_hex_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_bin_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 66: etat_suivant = 2; break; // case 'B':
        case 98: etat_suivant = 2; break; // case 'b':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_bin_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_bin_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_bin_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_bin_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 79: etat_suivant = 2; break; // case 'O':
        case 111: etat_suivant = 2; break; // case 'o':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        case 48: etat_suivant = 1; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 2; break; // case '0':
        case 49: etat_suivant = 1; break; // case '1':
        case 50: etat_suivant = 1; break; // case '2':
        case 51: etat_suivant = 1; break; // case '3':
        case 52: etat_suivant = 1; break; // case '4':
        case 53: etat_suivant = 1; break; // case '5':
        case 54: etat_suivant = 1; break; // case '6':
        case 55: etat_suivant = 1; break; // case '7':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 48: etat_suivant = 2; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_integer_oct_vc_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 == 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 46: etat_suivant = 5; break; // case '.':
        case 48: etat_suivant = 2; break; // case '0':
        case 49: etat_suivant = 2; break; // case '1':
        case 50: etat_suivant = 2; break; // case '2':
        case 51: etat_suivant = 2; break; // case '3':
        case 52: etat_suivant = 2; break; // case '4':
        case 53: etat_suivant = 2; break; // case '5':
        case 54: etat_suivant = 2; break; // case '6':
        case 55: etat_suivant = 2; break; // case '7':
        case 56: etat_suivant = 2; break; // case '8':
        case 57: etat_suivant = 2; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 48: etat_suivant = 5; break; // case '0':
        case 49: etat_suivant = 5; break; // case '1':
        case 50: etat_suivant = 5; break; // case '2':
        case 51: etat_suivant = 5; break; // case '3':
        case 52: etat_suivant = 5; break; // case '4':
        case 53: etat_suivant = 5; break; // case '5':
        case 54: etat_suivant = 5; break; // case '6':
        case 55: etat_suivant = 5; break; // case '7':
        case 56: etat_suivant = 5; break; // case '8':
        case 57: etat_suivant = 5; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 46: etat_suivant = 3; break; // case '.':
        case 48: etat_suivant = 2; break; // case '0':
        case 49: etat_suivant = 2; break; // case '1':
        case 50: etat_suivant = 2; break; // case '2':
        case 51: etat_suivant = 2; break; // case '3':
        case 52: etat_suivant = 2; break; // case '4':
        case 53: etat_suivant = 2; break; // case '5':
        case 54: etat_suivant = 2; break; // case '6':
        case 55: etat_suivant = 2; break; // case '7':
        case 56: etat_suivant = 2; break; // case '8':
        case 57: etat_suivant = 2; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 48: etat_suivant = 5; break; // case '0':
        case 49: etat_suivant = 5; break; // case '1':
        case 50: etat_suivant = 5; break; // case '2':
        case 51: etat_suivant = 5; break; // case '3':
        case 52: etat_suivant = 5; break; // case '4':
        case 53: etat_suivant = 5; break; // case '5':
        case 54: etat_suivant = 5; break; // case '6':
        case 55: etat_suivant = 5; break; // case '7':
        case 56: etat_suivant = 5; break; // case '8':
        case 57: etat_suivant = 5; break; // case '9':
        case 70: etat_suivant = 1; break; // case 'F':
        case 76: etat_suivant = 1; break; // case 'L':
        case 102: etat_suivant = 1; break; // case 'f':
        case 108: etat_suivant = 1; break; // case 'l':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_simple_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_initial_get(void) {
  return 8;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 == 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    case 6: etat_final_huh = (0 != 0); break;
    case 7: etat_final_huh = (0 != 0); break;
    case 8: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 4; break; // case '0':
        case 49: etat_suivant = 4; break; // case '1':
        case 50: etat_suivant = 4; break; // case '2':
        case 51: etat_suivant = 4; break; // case '3':
        case 52: etat_suivant = 4; break; // case '4':
        case 53: etat_suivant = 4; break; // case '5':
        case 54: etat_suivant = 4; break; // case '6':
        case 55: etat_suivant = 4; break; // case '7':
        case 56: etat_suivant = 4; break; // case '8':
        case 57: etat_suivant = 4; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        case 69: etat_suivant = 5; break; // case 'E':
        case 101: etat_suivant = 5; break; // case 'e':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 4; break; // case '0':
        case 49: etat_suivant = 4; break; // case '1':
        case 50: etat_suivant = 4; break; // case '2':
        case 51: etat_suivant = 4; break; // case '3':
        case 52: etat_suivant = 4; break; // case '4':
        case 53: etat_suivant = 4; break; // case '5':
        case 54: etat_suivant = 4; break; // case '6':
        case 55: etat_suivant = 4; break; // case '7':
        case 56: etat_suivant = 4; break; // case '8':
        case 57: etat_suivant = 4; break; // case '9':
        case 70: etat_suivant = 1; break; // case 'F':
        case 76: etat_suivant = 1; break; // case 'L':
        case 102: etat_suivant = 1; break; // case 'f':
        case 108: etat_suivant = 1; break; // case 'l':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 43: etat_suivant = 2; break; // case '+':
        case 45: etat_suivant = 2; break; // case '-':
        case 48: etat_suivant = 4; break; // case '0':
        case 49: etat_suivant = 4; break; // case '1':
        case 50: etat_suivant = 4; break; // case '2':
        case 51: etat_suivant = 4; break; // case '3':
        case 52: etat_suivant = 4; break; // case '4':
        case 53: etat_suivant = 4; break; // case '5':
        case 54: etat_suivant = 4; break; // case '6':
        case 55: etat_suivant = 4; break; // case '7':
        case 56: etat_suivant = 4; break; // case '8':
        case 57: etat_suivant = 4; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 6: {
      switch (lettre) {
        case 46: etat_suivant = 3; break; // case '.':
        case 48: etat_suivant = 6; break; // case '0':
        case 49: etat_suivant = 6; break; // case '1':
        case 50: etat_suivant = 6; break; // case '2':
        case 51: etat_suivant = 6; break; // case '3':
        case 52: etat_suivant = 6; break; // case '4':
        case 53: etat_suivant = 6; break; // case '5':
        case 54: etat_suivant = 6; break; // case '6':
        case 55: etat_suivant = 6; break; // case '7':
        case 56: etat_suivant = 6; break; // case '8':
        case 57: etat_suivant = 6; break; // case '9':
        case 69: etat_suivant = 5; break; // case 'E':
        case 101: etat_suivant = 5; break; // case 'e':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 7: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 8: {
      switch (lettre) {
        case 46: etat_suivant = 7; break; // case '.':
        case 48: etat_suivant = 6; break; // case '0':
        case 49: etat_suivant = 6; break; // case '1':
        case 50: etat_suivant = 6; break; // case '2':
        case 51: etat_suivant = 6; break; // case '3':
        case 52: etat_suivant = 6; break; // case '4':
        case 53: etat_suivant = 6; break; // case '5':
        case 54: etat_suivant = 6; break; // case '6':
        case 55: etat_suivant = 6; break; // case '7':
        case 56: etat_suivant = 6; break; // case '8':
        case 57: etat_suivant = 6; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_initial_get(void) {
  return 10;
}


int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    case 6: etat_final_huh = (0 == 0); break;
    case 7: etat_final_huh = (0 != 0); break;
    case 8: etat_final_huh = (0 != 0); break;
    case 9: etat_final_huh = (0 != 0); break;
    case 10: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 48: etat_suivant = 6; break; // case '0':
        case 49: etat_suivant = 6; break; // case '1':
        case 50: etat_suivant = 6; break; // case '2':
        case 51: etat_suivant = 6; break; // case '3':
        case 52: etat_suivant = 6; break; // case '4':
        case 53: etat_suivant = 6; break; // case '5':
        case 54: etat_suivant = 6; break; // case '6':
        case 55: etat_suivant = 6; break; // case '7':
        case 56: etat_suivant = 6; break; // case '8':
        case 57: etat_suivant = 6; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        case 65: etat_suivant = 3; break; // case 'A':
        case 66: etat_suivant = 3; break; // case 'B':
        case 67: etat_suivant = 3; break; // case 'C':
        case 68: etat_suivant = 3; break; // case 'D':
        case 69: etat_suivant = 3; break; // case 'E':
        case 70: etat_suivant = 3; break; // case 'F':
        case 80: etat_suivant = 7; break; // case 'P':
        case 97: etat_suivant = 3; break; // case 'a':
        case 98: etat_suivant = 3; break; // case 'b':
        case 99: etat_suivant = 3; break; // case 'c':
        case 100: etat_suivant = 3; break; // case 'd':
        case 101: etat_suivant = 3; break; // case 'e':
        case 102: etat_suivant = 3; break; // case 'f':
        case 112: etat_suivant = 7; break; // case 'p':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 48: etat_suivant = 3; break; // case '0':
        case 49: etat_suivant = 3; break; // case '1':
        case 50: etat_suivant = 3; break; // case '2':
        case 51: etat_suivant = 3; break; // case '3':
        case 52: etat_suivant = 3; break; // case '4':
        case 53: etat_suivant = 3; break; // case '5':
        case 54: etat_suivant = 3; break; // case '6':
        case 55: etat_suivant = 3; break; // case '7':
        case 56: etat_suivant = 3; break; // case '8':
        case 57: etat_suivant = 3; break; // case '9':
        case 65: etat_suivant = 3; break; // case 'A':
        case 66: etat_suivant = 3; break; // case 'B':
        case 67: etat_suivant = 3; break; // case 'C':
        case 68: etat_suivant = 3; break; // case 'D':
        case 69: etat_suivant = 3; break; // case 'E':
        case 70: etat_suivant = 3; break; // case 'F':
        case 97: etat_suivant = 3; break; // case 'a':
        case 98: etat_suivant = 3; break; // case 'b':
        case 99: etat_suivant = 3; break; // case 'c':
        case 100: etat_suivant = 3; break; // case 'd':
        case 101: etat_suivant = 3; break; // case 'e':
        case 102: etat_suivant = 3; break; // case 'f':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 88: etat_suivant = 9; break; // case 'X':
        case 120: etat_suivant = 9; break; // case 'x':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 6: {
      switch (lettre) {
        case 48: etat_suivant = 6; break; // case '0':
        case 49: etat_suivant = 6; break; // case '1':
        case 50: etat_suivant = 6; break; // case '2':
        case 51: etat_suivant = 6; break; // case '3':
        case 52: etat_suivant = 6; break; // case '4':
        case 53: etat_suivant = 6; break; // case '5':
        case 54: etat_suivant = 6; break; // case '6':
        case 55: etat_suivant = 6; break; // case '7':
        case 56: etat_suivant = 6; break; // case '8':
        case 57: etat_suivant = 6; break; // case '9':
        case 70: etat_suivant = 1; break; // case 'F':
        case 76: etat_suivant = 1; break; // case 'L':
        case 102: etat_suivant = 1; break; // case 'f':
        case 108: etat_suivant = 1; break; // case 'l':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 7: {
      switch (lettre) {
        case 43: etat_suivant = 2; break; // case '+':
        case 45: etat_suivant = 2; break; // case '-':
        case 48: etat_suivant = 6; break; // case '0':
        case 49: etat_suivant = 6; break; // case '1':
        case 50: etat_suivant = 6; break; // case '2':
        case 51: etat_suivant = 6; break; // case '3':
        case 52: etat_suivant = 6; break; // case '4':
        case 53: etat_suivant = 6; break; // case '5':
        case 54: etat_suivant = 6; break; // case '6':
        case 55: etat_suivant = 6; break; // case '7':
        case 56: etat_suivant = 6; break; // case '8':
        case 57: etat_suivant = 6; break; // case '9':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 8: {
      switch (lettre) {
        case 46: etat_suivant = 3; break; // case '.':
        case 48: etat_suivant = 8; break; // case '0':
        case 49: etat_suivant = 8; break; // case '1':
        case 50: etat_suivant = 8; break; // case '2':
        case 51: etat_suivant = 8; break; // case '3':
        case 52: etat_suivant = 8; break; // case '4':
        case 53: etat_suivant = 8; break; // case '5':
        case 54: etat_suivant = 8; break; // case '6':
        case 55: etat_suivant = 8; break; // case '7':
        case 56: etat_suivant = 8; break; // case '8':
        case 57: etat_suivant = 8; break; // case '9':
        case 65: etat_suivant = 8; break; // case 'A':
        case 66: etat_suivant = 8; break; // case 'B':
        case 67: etat_suivant = 8; break; // case 'C':
        case 68: etat_suivant = 8; break; // case 'D':
        case 69: etat_suivant = 8; break; // case 'E':
        case 70: etat_suivant = 8; break; // case 'F':
        case 80: etat_suivant = 7; break; // case 'P':
        case 97: etat_suivant = 8; break; // case 'a':
        case 98: etat_suivant = 8; break; // case 'b':
        case 99: etat_suivant = 8; break; // case 'c':
        case 100: etat_suivant = 8; break; // case 'd':
        case 101: etat_suivant = 8; break; // case 'e':
        case 102: etat_suivant = 8; break; // case 'f':
        case 112: etat_suivant = 7; break; // case 'p':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 9: {
      switch (lettre) {
        case 46: etat_suivant = 4; break; // case '.':
        case 48: etat_suivant = 8; break; // case '0':
        case 49: etat_suivant = 8; break; // case '1':
        case 50: etat_suivant = 8; break; // case '2':
        case 51: etat_suivant = 8; break; // case '3':
        case 52: etat_suivant = 8; break; // case '4':
        case 53: etat_suivant = 8; break; // case '5':
        case 54: etat_suivant = 8; break; // case '6':
        case 55: etat_suivant = 8; break; // case '7':
        case 56: etat_suivant = 8; break; // case '8':
        case 57: etat_suivant = 8; break; // case '9':
        case 65: etat_suivant = 8; break; // case 'A':
        case 66: etat_suivant = 8; break; // case 'B':
        case 67: etat_suivant = 8; break; // case 'C':
        case 68: etat_suivant = 8; break; // case 'D':
        case 69: etat_suivant = 8; break; // case 'E':
        case 70: etat_suivant = 8; break; // case 'F':
        case 97: etat_suivant = 8; break; // case 'a':
        case 98: etat_suivant = 8; break; // case 'b':
        case 99: etat_suivant = 8; break; // case 'c':
        case 100: etat_suivant = 8; break; // case 'd':
        case 101: etat_suivant = 8; break; // case 'e':
        case 102: etat_suivant = 8; break; // case 'f':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 10: {
      switch (lettre) {
        case 48: etat_suivant = 5; break; // case '0':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_char_simple_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_char_simple_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 10: etat_suivant = 0; break; // case '\n':
        case 39: etat_suivant = 0; break; // case ''':
        case 92: etat_suivant = 0; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 39: etat_suivant = 3; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_char_simple_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_char_simple_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_char_simple_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 10: etat_suivant = 2; break; // case '\n':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 39: etat_suivant = 3; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_char_simple_newline_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_char_empty_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_char_empty_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_char_empty_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_char_empty_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 39: etat_suivant = 2; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_char_empty_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_char_empty_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_char_empty_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_char_empty_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_char_escape_etat_initial_get(void) {
  return 5;
}


int lexer_lexer_for_c_language_automaton_token_char_escape_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_char_escape_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_char_escape_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 92: etat_suivant = 3; break; // case '\\':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 39: etat_suivant = 4; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_char_escape_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_char_escape_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_char_escape_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_char_escape_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_char_wide_etat_initial_get(void) {
  return 7;
}


int lexer_lexer_for_c_language_automaton_token_char_wide_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_char_wide_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 == 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    case 6: etat_final_huh = (0 != 0); break;
    case 7: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_char_wide_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 92: etat_suivant = 5; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 39: etat_suivant = 1; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 39: etat_suivant = 4; break; // case ''':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 6: {
      switch (lettre) {
        case 39: etat_suivant = 3; break; // case ''':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 7: {
      switch (lettre) {
        case 76: etat_suivant = 6; break; // case 'L':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_char_wide_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_char_wide_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_char_wide_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_char_wide_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_string_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_string_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_string_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_string_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 0; break; // case '\n':
        case 34: etat_suivant = 1; break; // case '\"':
        case 92: etat_suivant = 3; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 34: etat_suivant = 2; break; // case '\"':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_string_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_string_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_string_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_string_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        case 34: etat_suivant = 0; break; // case '\"':
        case 92: etat_suivant = 3; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 34: etat_suivant = 2; break; // case '\"':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_string_wide_etat_initial_get(void) {
  return 5;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_string_wide_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 0; break; // case '\n':
        case 34: etat_suivant = 1; break; // case '\"':
        case 92: etat_suivant = 3; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 34: etat_suivant = 2; break; // case '\"':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 76: etat_suivant = 4; break; // case 'L':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_string_wide_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_string_wide_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_string_wide_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_initial_get(void) {
  return 5;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    case 5: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 10: etat_suivant = 1; break; // case '\n':
        case 34: etat_suivant = 0; break; // case '\"':
        case 92: etat_suivant = 3; break; // case '\\':
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        default: etat_suivant = 2; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 34: etat_suivant = 2; break; // case '\"':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 5: {
      switch (lettre) {
        case 76: etat_suivant = 4; break; // case 'L':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_open_par_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_open_par_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_open_par_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_open_par_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 40: etat_suivant = 1; break; // case '(':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_open_par_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_open_par_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_open_par_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_open_par_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_close_par_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_close_par_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_close_par_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_close_par_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 41: etat_suivant = 1; break; // case ')':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_close_par_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_close_par_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_close_par_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_close_par_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_open_bracket_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 91: etat_suivant = 1; break; // case '[':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_open_bracket_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_open_bracket_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_open_bracket_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_open_bracket_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_close_bracket_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 93: etat_suivant = 1; break; // case ']':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_close_bracket_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_close_bracket_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_close_bracket_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_close_bracket_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_open_brace_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_open_brace_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_open_brace_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_open_brace_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 123: etat_suivant = 1; break; // case '{':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_open_brace_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_open_brace_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_open_brace_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_open_brace_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_close_brace_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_close_brace_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_close_brace_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_close_brace_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 125: etat_suivant = 1; break; // case '}':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_close_brace_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_close_brace_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_close_brace_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_close_brace_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_comma_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_comma_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_comma_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_comma_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 44: etat_suivant = 1; break; // case ',':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_comma_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_comma_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_comma_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_comma_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_point_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_point_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_point_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_point_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 46: etat_suivant = 1; break; // case '.':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_point_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_point_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_point_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_point_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 62: etat_suivant = 1; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 45: etat_suivant = 2; break; // case '-':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_arrow_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_semicolon_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_semicolon_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_semicolon_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_semicolon_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 59: etat_suivant = 1; break; // case ';':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_semicolon_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_semicolon_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_semicolon_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_semicolon_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_star_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_star_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_star_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_star_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 42: etat_suivant = 1; break; // case '*':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_star_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_star_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_star_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_star_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_plus_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 43: etat_suivant = 1; break; // case '+':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_plus_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_plus_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_plus_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_plus_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_minus_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 45: etat_suivant = 1; break; // case '-':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_minus_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_minus_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_minus_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_minus_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 47: etat_suivant = 1; break; // case '/':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_rdiv_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 126: etat_suivant = 1; break; // case '~':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_tilde_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 38: etat_suivant = 1; break; // case '&':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 38: etat_suivant = 1; break; // case '&':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 38: etat_suivant = 2; break; // case '&':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_double_perluete_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 124: etat_suivant = 1; break; // case '|':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 124: etat_suivant = 1; break; // case '|':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 124: etat_suivant = 2; break; // case '|':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_double_pipe_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 61: etat_suivant = 2; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_equal_huh_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_hat_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 94: etat_suivant = 1; break; // case '^':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_hat_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_hat_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_hat_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_hat_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_percent_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 37: etat_suivant = 1; break; // case '%':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_percent_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_percent_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_percent_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_percent_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_bang_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 33: etat_suivant = 1; break; // case '!':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_bang_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_bang_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_bang_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_bang_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 33: etat_suivant = 2; break; // case '!':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_different_huh_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_inf_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 60: etat_suivant = 1; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_inf_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_inf_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_inf_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_inf_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_sup_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 62: etat_suivant = 1; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_sup_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_sup_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_sup_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_sup_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 60: etat_suivant = 2; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 62: etat_suivant = 2; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 43: etat_suivant = 1; break; // case '+':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 43: etat_suivant = 2; break; // case '+':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_plus_plus_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 45: etat_suivant = 1; break; // case '-':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 45: etat_suivant = 2; break; // case '-':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 60: etat_suivant = 1; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 60: etat_suivant = 2; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_lshift_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 62: etat_suivant = 1; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 62: etat_suivant = 2; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_rshift_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_huh_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 63: etat_suivant = 1; break; // case '?':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_huh_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_huh_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_huh_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_huh_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_colon_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 58: etat_suivant = 1; break; // case ':':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_colon_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_colon_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_colon_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_colon_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_ellipsis_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 46: etat_suivant = 1; break; // case '.':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 46: etat_suivant = 2; break; // case '.':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 46: etat_suivant = 3; break; // case '.':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_ellipsis_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_ellipsis_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_ellipsis_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_ellipsis_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_initial_get(void) {
  return 2;
}


int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 42: etat_suivant = 2; break; // case '*':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_star_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 47: etat_suivant = 2; break; // case '/':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 37: etat_suivant = 2; break; // case '%':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_percent_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 43: etat_suivant = 2; break; // case '+':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_plus_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 45: etat_suivant = 2; break; // case '-':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_minus_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 60: etat_suivant = 2; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 60: etat_suivant = 3; break; // case '<':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_initial_get(void) {
  return 4;
}


int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    case 4: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 62: etat_suivant = 2; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 4: {
      switch (lettre) {
        case 62: etat_suivant = 3; break; // case '>':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 38: etat_suivant = 2; break; // case '&':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 94: etat_suivant = 2; break; // case '^':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_hat_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_final_huh(etat);
}
int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_initial_get(void) {
  return 3;
}


int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_puits_huh(const int etat) {
  return (0 == etat);
}


int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_final_huh(const int etat) {
  int etat_final_huh;
  switch (etat) {
    case 0: etat_final_huh = (0 != 0); break;
    case 1: etat_final_huh = (0 == 0); break;
    case 2: etat_final_huh = (0 != 0); break;
    case 3: etat_final_huh = (0 != 0); break;
    default: assert(0 != 0); etat_final_huh = (0 != 0); break;
  }
  return etat_final_huh;
}


int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_suivant_get(const int etat_courant, const char lettre) {
  int etat_suivant;
  switch (etat_courant) {
    case 0: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 1: {
      switch (lettre) {
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 2: {
      switch (lettre) {
        case 61: etat_suivant = 1; break; // case '=':
        default: etat_suivant = 0; break;
      }
    }
    break;
    case 3: {
      switch (lettre) {
        case 124: etat_suivant = 2; break; // case '|':
        default: etat_suivant = 0; break;
      }
    }
    break;
    default: assert((0 != 0)); etat_suivant = 0; break;
  }
  return etat_suivant;
}


int lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_mot_reconnu_huh(const char * mot) {
  assert(NULL != mot);
  const int len = strlen(mot);
  
  int etat = lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_initial_get();
  
  for (int i = 0; i < len; i++) {
    etat = lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_suivant_get(etat, mot[i]);
  }
  
  
  return lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_final_huh(etat);
}




static int type_du_plus_long_prefixe_reconnu(const char * mot, lexer_lexer_for_c_language_token_type_t * type_ptr, int * longueur_du_plus_long_prefixe_reconnu_ptr);


int type_du_plus_long_prefixe_reconnu(const char * mot, lexer_lexer_for_c_language_token_type_t * type_ptr, int * longueur_du_plus_long_prefixe_reconnu_ptr) {
  assert(mot != NULL);
  assert(type_ptr != NULL);
  assert(longueur_du_plus_long_prefixe_reconnu_ptr != NULL);
  
  *longueur_du_plus_long_prefixe_reconnu_ptr = -1;
  
  int etat_courant[71];
  char lettre;
  
  {
    etat_courant[0] = lexer_lexer_for_c_language_automaton_token_blank_etat_initial_get();
    etat_courant[1] = lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_initial_get();
    etat_courant[2] = lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_initial_get();
    etat_courant[3] = lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_initial_get();
    etat_courant[4] = lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_initial_get();
    etat_courant[5] = lexer_lexer_for_c_language_automaton_token_ident_etat_initial_get();
    etat_courant[6] = lexer_lexer_for_c_language_automaton_token_integer_zero_etat_initial_get();
    etat_courant[7] = lexer_lexer_for_c_language_automaton_token_integer_dec_etat_initial_get();
    etat_courant[8] = lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_initial_get();
    etat_courant[9] = lexer_lexer_for_c_language_automaton_token_integer_hex_etat_initial_get();
    etat_courant[10] = lexer_lexer_for_c_language_automaton_token_integer_bin_etat_initial_get();
    etat_courant[11] = lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_initial_get();
    etat_courant[12] = lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_initial_get();
    etat_courant[13] = lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_initial_get();
    etat_courant[14] = lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_initial_get();
    etat_courant[15] = lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_initial_get();
    etat_courant[16] = lexer_lexer_for_c_language_automaton_token_char_simple_etat_initial_get();
    etat_courant[17] = lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_initial_get();
    etat_courant[18] = lexer_lexer_for_c_language_automaton_token_char_empty_etat_initial_get();
    etat_courant[19] = lexer_lexer_for_c_language_automaton_token_char_escape_etat_initial_get();
    etat_courant[20] = lexer_lexer_for_c_language_automaton_token_char_wide_etat_initial_get();
    etat_courant[21] = lexer_lexer_for_c_language_automaton_token_string_etat_initial_get();
    etat_courant[22] = lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_initial_get();
    etat_courant[23] = lexer_lexer_for_c_language_automaton_token_string_wide_etat_initial_get();
    etat_courant[24] = lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_initial_get();
    etat_courant[25] = lexer_lexer_for_c_language_automaton_token_open_par_etat_initial_get();
    etat_courant[26] = lexer_lexer_for_c_language_automaton_token_close_par_etat_initial_get();
    etat_courant[27] = lexer_lexer_for_c_language_automaton_token_open_bracket_etat_initial_get();
    etat_courant[28] = lexer_lexer_for_c_language_automaton_token_close_bracket_etat_initial_get();
    etat_courant[29] = lexer_lexer_for_c_language_automaton_token_open_brace_etat_initial_get();
    etat_courant[30] = lexer_lexer_for_c_language_automaton_token_close_brace_etat_initial_get();
    etat_courant[31] = lexer_lexer_for_c_language_automaton_token_comma_etat_initial_get();
    etat_courant[32] = lexer_lexer_for_c_language_automaton_token_point_operator_etat_initial_get();
    etat_courant[33] = lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_initial_get();
    etat_courant[34] = lexer_lexer_for_c_language_automaton_token_semicolon_etat_initial_get();
    etat_courant[35] = lexer_lexer_for_c_language_automaton_token_star_operator_etat_initial_get();
    etat_courant[36] = lexer_lexer_for_c_language_automaton_token_plus_operator_etat_initial_get();
    etat_courant[37] = lexer_lexer_for_c_language_automaton_token_minus_operator_etat_initial_get();
    etat_courant[38] = lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_initial_get();
    etat_courant[39] = lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_initial_get();
    etat_courant[40] = lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_initial_get();
    etat_courant[41] = lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_initial_get();
    etat_courant[42] = lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_initial_get();
    etat_courant[43] = lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_initial_get();
    etat_courant[44] = lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_initial_get();
    etat_courant[45] = lexer_lexer_for_c_language_automaton_token_hat_operator_etat_initial_get();
    etat_courant[46] = lexer_lexer_for_c_language_automaton_token_percent_operator_etat_initial_get();
    etat_courant[47] = lexer_lexer_for_c_language_automaton_token_bang_operator_etat_initial_get();
    etat_courant[48] = lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_initial_get();
    etat_courant[49] = lexer_lexer_for_c_language_automaton_token_inf_operator_etat_initial_get();
    etat_courant[50] = lexer_lexer_for_c_language_automaton_token_sup_operator_etat_initial_get();
    etat_courant[51] = lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_initial_get();
    etat_courant[52] = lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_initial_get();
    etat_courant[53] = lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_initial_get();
    etat_courant[54] = lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_initial_get();
    etat_courant[55] = lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_initial_get();
    etat_courant[56] = lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_initial_get();
    etat_courant[57] = lexer_lexer_for_c_language_automaton_token_huh_operator_etat_initial_get();
    etat_courant[58] = lexer_lexer_for_c_language_automaton_token_colon_operator_etat_initial_get();
    etat_courant[59] = lexer_lexer_for_c_language_automaton_token_ellipsis_etat_initial_get();
    etat_courant[60] = lexer_lexer_for_c_language_automaton_token_assign_operator_etat_initial_get();
    etat_courant[61] = lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_initial_get();
    etat_courant[62] = lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_initial_get();
    etat_courant[63] = lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_initial_get();
    etat_courant[64] = lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_initial_get();
    etat_courant[65] = lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_initial_get();
    etat_courant[66] = lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_initial_get();
    etat_courant[67] = lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_initial_get();
    etat_courant[68] = lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_initial_get();
    etat_courant[69] = lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_initial_get();
    etat_courant[70] = lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_initial_get();
  }
  
  int indice_automate_ayant_reconnu_le_plus_long_prefixe;
  indice_automate_ayant_reconnu_le_plus_long_prefixe = -1;
  
  for (int j = 0; mot[j] != '\0'; j++) {
    lettre = mot[j];
    {
      etat_courant[0] = lexer_lexer_for_c_language_automaton_token_blank_etat_suivant_get(etat_courant[0], lettre);
      etat_courant[1] = lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_suivant_get(etat_courant[1], lettre);
      etat_courant[2] = lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_suivant_get(etat_courant[2], lettre);
      etat_courant[3] = lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_suivant_get(etat_courant[3], lettre);
      etat_courant[4] = lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_suivant_get(etat_courant[4], lettre);
      etat_courant[5] = lexer_lexer_for_c_language_automaton_token_ident_etat_suivant_get(etat_courant[5], lettre);
      etat_courant[6] = lexer_lexer_for_c_language_automaton_token_integer_zero_etat_suivant_get(etat_courant[6], lettre);
      etat_courant[7] = lexer_lexer_for_c_language_automaton_token_integer_dec_etat_suivant_get(etat_courant[7], lettre);
      etat_courant[8] = lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_suivant_get(etat_courant[8], lettre);
      etat_courant[9] = lexer_lexer_for_c_language_automaton_token_integer_hex_etat_suivant_get(etat_courant[9], lettre);
      etat_courant[10] = lexer_lexer_for_c_language_automaton_token_integer_bin_etat_suivant_get(etat_courant[10], lettre);
      etat_courant[11] = lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_suivant_get(etat_courant[11], lettre);
      etat_courant[12] = lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_suivant_get(etat_courant[12], lettre);
      etat_courant[13] = lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_suivant_get(etat_courant[13], lettre);
      etat_courant[14] = lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_suivant_get(etat_courant[14], lettre);
      etat_courant[15] = lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_suivant_get(etat_courant[15], lettre);
      etat_courant[16] = lexer_lexer_for_c_language_automaton_token_char_simple_etat_suivant_get(etat_courant[16], lettre);
      etat_courant[17] = lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_suivant_get(etat_courant[17], lettre);
      etat_courant[18] = lexer_lexer_for_c_language_automaton_token_char_empty_etat_suivant_get(etat_courant[18], lettre);
      etat_courant[19] = lexer_lexer_for_c_language_automaton_token_char_escape_etat_suivant_get(etat_courant[19], lettre);
      etat_courant[20] = lexer_lexer_for_c_language_automaton_token_char_wide_etat_suivant_get(etat_courant[20], lettre);
      etat_courant[21] = lexer_lexer_for_c_language_automaton_token_string_etat_suivant_get(etat_courant[21], lettre);
      etat_courant[22] = lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_suivant_get(etat_courant[22], lettre);
      etat_courant[23] = lexer_lexer_for_c_language_automaton_token_string_wide_etat_suivant_get(etat_courant[23], lettre);
      etat_courant[24] = lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_suivant_get(etat_courant[24], lettre);
      etat_courant[25] = lexer_lexer_for_c_language_automaton_token_open_par_etat_suivant_get(etat_courant[25], lettre);
      etat_courant[26] = lexer_lexer_for_c_language_automaton_token_close_par_etat_suivant_get(etat_courant[26], lettre);
      etat_courant[27] = lexer_lexer_for_c_language_automaton_token_open_bracket_etat_suivant_get(etat_courant[27], lettre);
      etat_courant[28] = lexer_lexer_for_c_language_automaton_token_close_bracket_etat_suivant_get(etat_courant[28], lettre);
      etat_courant[29] = lexer_lexer_for_c_language_automaton_token_open_brace_etat_suivant_get(etat_courant[29], lettre);
      etat_courant[30] = lexer_lexer_for_c_language_automaton_token_close_brace_etat_suivant_get(etat_courant[30], lettre);
      etat_courant[31] = lexer_lexer_for_c_language_automaton_token_comma_etat_suivant_get(etat_courant[31], lettre);
      etat_courant[32] = lexer_lexer_for_c_language_automaton_token_point_operator_etat_suivant_get(etat_courant[32], lettre);
      etat_courant[33] = lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_suivant_get(etat_courant[33], lettre);
      etat_courant[34] = lexer_lexer_for_c_language_automaton_token_semicolon_etat_suivant_get(etat_courant[34], lettre);
      etat_courant[35] = lexer_lexer_for_c_language_automaton_token_star_operator_etat_suivant_get(etat_courant[35], lettre);
      etat_courant[36] = lexer_lexer_for_c_language_automaton_token_plus_operator_etat_suivant_get(etat_courant[36], lettre);
      etat_courant[37] = lexer_lexer_for_c_language_automaton_token_minus_operator_etat_suivant_get(etat_courant[37], lettre);
      etat_courant[38] = lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_suivant_get(etat_courant[38], lettre);
      etat_courant[39] = lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_suivant_get(etat_courant[39], lettre);
      etat_courant[40] = lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_suivant_get(etat_courant[40], lettre);
      etat_courant[41] = lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_suivant_get(etat_courant[41], lettre);
      etat_courant[42] = lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_suivant_get(etat_courant[42], lettre);
      etat_courant[43] = lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_suivant_get(etat_courant[43], lettre);
      etat_courant[44] = lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_suivant_get(etat_courant[44], lettre);
      etat_courant[45] = lexer_lexer_for_c_language_automaton_token_hat_operator_etat_suivant_get(etat_courant[45], lettre);
      etat_courant[46] = lexer_lexer_for_c_language_automaton_token_percent_operator_etat_suivant_get(etat_courant[46], lettre);
      etat_courant[47] = lexer_lexer_for_c_language_automaton_token_bang_operator_etat_suivant_get(etat_courant[47], lettre);
      etat_courant[48] = lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_suivant_get(etat_courant[48], lettre);
      etat_courant[49] = lexer_lexer_for_c_language_automaton_token_inf_operator_etat_suivant_get(etat_courant[49], lettre);
      etat_courant[50] = lexer_lexer_for_c_language_automaton_token_sup_operator_etat_suivant_get(etat_courant[50], lettre);
      etat_courant[51] = lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_suivant_get(etat_courant[51], lettre);
      etat_courant[52] = lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_suivant_get(etat_courant[52], lettre);
      etat_courant[53] = lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_suivant_get(etat_courant[53], lettre);
      etat_courant[54] = lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_suivant_get(etat_courant[54], lettre);
      etat_courant[55] = lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_suivant_get(etat_courant[55], lettre);
      etat_courant[56] = lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_suivant_get(etat_courant[56], lettre);
      etat_courant[57] = lexer_lexer_for_c_language_automaton_token_huh_operator_etat_suivant_get(etat_courant[57], lettre);
      etat_courant[58] = lexer_lexer_for_c_language_automaton_token_colon_operator_etat_suivant_get(etat_courant[58], lettre);
      etat_courant[59] = lexer_lexer_for_c_language_automaton_token_ellipsis_etat_suivant_get(etat_courant[59], lettre);
      etat_courant[60] = lexer_lexer_for_c_language_automaton_token_assign_operator_etat_suivant_get(etat_courant[60], lettre);
      etat_courant[61] = lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_suivant_get(etat_courant[61], lettre);
      etat_courant[62] = lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_suivant_get(etat_courant[62], lettre);
      etat_courant[63] = lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_suivant_get(etat_courant[63], lettre);
      etat_courant[64] = lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_suivant_get(etat_courant[64], lettre);
      etat_courant[65] = lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_suivant_get(etat_courant[65], lettre);
      etat_courant[66] = lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_suivant_get(etat_courant[66], lettre);
      etat_courant[67] = lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_suivant_get(etat_courant[67], lettre);
      etat_courant[68] = lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_suivant_get(etat_courant[68], lettre);
      etat_courant[69] = lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_suivant_get(etat_courant[69], lettre);
      etat_courant[70] = lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_suivant_get(etat_courant[70], lettre);
    }
  
    {
      if (lexer_lexer_for_c_language_automaton_token_blank_etat_final_huh(etat_courant[0])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 0;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_final_huh(etat_courant[1])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 1;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_final_huh(etat_courant[2])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 2;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_final_huh(etat_courant[3])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 3;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_final_huh(etat_courant[4])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 4;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_ident_etat_final_huh(etat_courant[5])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 5;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_zero_etat_final_huh(etat_courant[6])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 6;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_dec_etat_final_huh(etat_courant[7])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 7;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_final_huh(etat_courant[8])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 8;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_hex_etat_final_huh(etat_courant[9])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 9;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_bin_etat_final_huh(etat_courant[10])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 10;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_final_huh(etat_courant[11])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 11;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_final_huh(etat_courant[12])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 12;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_final_huh(etat_courant[13])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 13;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_final_huh(etat_courant[14])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 14;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_final_huh(etat_courant[15])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 15;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_char_simple_etat_final_huh(etat_courant[16])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 16;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_final_huh(etat_courant[17])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 17;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_char_empty_etat_final_huh(etat_courant[18])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 18;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_char_escape_etat_final_huh(etat_courant[19])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 19;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_char_wide_etat_final_huh(etat_courant[20])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 20;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_string_etat_final_huh(etat_courant[21])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 21;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_final_huh(etat_courant[22])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 22;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_string_wide_etat_final_huh(etat_courant[23])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 23;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_final_huh(etat_courant[24])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 24;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_open_par_etat_final_huh(etat_courant[25])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 25;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_close_par_etat_final_huh(etat_courant[26])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 26;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_open_bracket_etat_final_huh(etat_courant[27])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 27;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_close_bracket_etat_final_huh(etat_courant[28])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 28;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_open_brace_etat_final_huh(etat_courant[29])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 29;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_close_brace_etat_final_huh(etat_courant[30])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 30;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_comma_etat_final_huh(etat_courant[31])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 31;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_point_operator_etat_final_huh(etat_courant[32])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 32;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_final_huh(etat_courant[33])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 33;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_semicolon_etat_final_huh(etat_courant[34])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 34;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_star_operator_etat_final_huh(etat_courant[35])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 35;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_plus_operator_etat_final_huh(etat_courant[36])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 36;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_minus_operator_etat_final_huh(etat_courant[37])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 37;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_final_huh(etat_courant[38])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 38;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_final_huh(etat_courant[39])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 39;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_final_huh(etat_courant[40])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 40;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_final_huh(etat_courant[41])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 41;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_final_huh(etat_courant[42])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 42;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_final_huh(etat_courant[43])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 43;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_final_huh(etat_courant[44])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 44;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_hat_operator_etat_final_huh(etat_courant[45])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 45;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_percent_operator_etat_final_huh(etat_courant[46])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 46;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_bang_operator_etat_final_huh(etat_courant[47])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 47;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_final_huh(etat_courant[48])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 48;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_inf_operator_etat_final_huh(etat_courant[49])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 49;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_sup_operator_etat_final_huh(etat_courant[50])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 50;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_final_huh(etat_courant[51])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 51;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_final_huh(etat_courant[52])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 52;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_final_huh(etat_courant[53])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 53;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_final_huh(etat_courant[54])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 54;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_final_huh(etat_courant[55])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 55;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_final_huh(etat_courant[56])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 56;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_huh_operator_etat_final_huh(etat_courant[57])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 57;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_colon_operator_etat_final_huh(etat_courant[58])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 58;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_ellipsis_etat_final_huh(etat_courant[59])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 59;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_operator_etat_final_huh(etat_courant[60])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 60;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_final_huh(etat_courant[61])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 61;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_final_huh(etat_courant[62])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 62;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_final_huh(etat_courant[63])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 63;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_final_huh(etat_courant[64])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 64;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_final_huh(etat_courant[65])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 65;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_final_huh(etat_courant[66])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 66;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_final_huh(etat_courant[67])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 67;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_final_huh(etat_courant[68])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 68;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_final_huh(etat_courant[69])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 69;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
      if (lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_final_huh(etat_courant[70])) {
        indice_automate_ayant_reconnu_le_plus_long_prefixe = 70;
        *longueur_du_plus_long_prefixe_reconnu_ptr = j+1;
      }
    }
    
    int tous_les_automates_sont_bloques_huh = (0 == 0);
    {
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_blank_etat_puits_huh(etat_courant[0]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_comment_multilines_etat_puits_huh(etat_courant[1]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_comment_oneline_cpp_etat_puits_huh(etat_courant[2]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_directive_mono_line_etat_puits_huh(etat_courant[3]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_directive_multi_lines_etat_puits_huh(etat_courant[4]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_ident_etat_puits_huh(etat_courant[5]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_zero_etat_puits_huh(etat_courant[6]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_dec_etat_puits_huh(etat_courant[7]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_dec_v2_etat_puits_huh(etat_courant[8]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_hex_etat_puits_huh(etat_courant[9]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_bin_etat_puits_huh(etat_courant[10]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_oct_vcc_etat_puits_huh(etat_courant[11]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_integer_oct_vc_etat_puits_huh(etat_courant[12]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_real_dec_simple_etat_puits_huh(etat_courant[13]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_real_dec_with_exp_etat_puits_huh(etat_courant[14]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_real_hex_with_exp_etat_puits_huh(etat_courant[15]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_char_simple_etat_puits_huh(etat_courant[16]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_char_simple_newline_etat_puits_huh(etat_courant[17]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_char_empty_etat_puits_huh(etat_courant[18]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_char_escape_etat_puits_huh(etat_courant[19]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_char_wide_etat_puits_huh(etat_courant[20]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_string_etat_puits_huh(etat_courant[21]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_string_ended_by_newline_etat_puits_huh(etat_courant[22]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_string_wide_etat_puits_huh(etat_courant[23]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_string_wide_ended_by_newline_etat_puits_huh(etat_courant[24]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_open_par_etat_puits_huh(etat_courant[25]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_close_par_etat_puits_huh(etat_courant[26]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_open_bracket_etat_puits_huh(etat_courant[27]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_close_bracket_etat_puits_huh(etat_courant[28]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_open_brace_etat_puits_huh(etat_courant[29]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_close_brace_etat_puits_huh(etat_courant[30]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_comma_etat_puits_huh(etat_courant[31]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_point_operator_etat_puits_huh(etat_courant[32]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_arrow_operator_etat_puits_huh(etat_courant[33]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_semicolon_etat_puits_huh(etat_courant[34]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_star_operator_etat_puits_huh(etat_courant[35]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_plus_operator_etat_puits_huh(etat_courant[36]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_minus_operator_etat_puits_huh(etat_courant[37]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_rdiv_operator_etat_puits_huh(etat_courant[38]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_tilde_operator_etat_puits_huh(etat_courant[39]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_simple_perluete_operator_etat_puits_huh(etat_courant[40]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_double_perluete_operator_etat_puits_huh(etat_courant[41]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_simple_pipe_operator_etat_puits_huh(etat_courant[42]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_double_pipe_operator_etat_puits_huh(etat_courant[43]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_equal_huh_operator_etat_puits_huh(etat_courant[44]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_hat_operator_etat_puits_huh(etat_courant[45]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_percent_operator_etat_puits_huh(etat_courant[46]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_bang_operator_etat_puits_huh(etat_courant[47]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_different_huh_operator_etat_puits_huh(etat_courant[48]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_inf_operator_etat_puits_huh(etat_courant[49]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_sup_operator_etat_puits_huh(etat_courant[50]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_inf_or_equal_operator_etat_puits_huh(etat_courant[51]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_sup_or_equal_operator_etat_puits_huh(etat_courant[52]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_plus_plus_operator_etat_puits_huh(etat_courant[53]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_minus_minus_operartor_etat_puits_huh(etat_courant[54]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_lshift_operator_etat_puits_huh(etat_courant[55]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_rshift_operator_etat_puits_huh(etat_courant[56]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_huh_operator_etat_puits_huh(etat_courant[57]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_colon_operator_etat_puits_huh(etat_courant[58]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_ellipsis_etat_puits_huh(etat_courant[59]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_operator_etat_puits_huh(etat_courant[60]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_star_operator_etat_puits_huh(etat_courant[61]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_rdiv_operator_etat_puits_huh(etat_courant[62]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_percent_operator_etat_puits_huh(etat_courant[63]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_plus_operator_etat_puits_huh(etat_courant[64]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_minus_operator_etat_puits_huh(etat_courant[65]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_lshift_operator_etat_puits_huh(etat_courant[66]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_rshift_operator_etat_puits_huh(etat_courant[67]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_perluete_operator_etat_puits_huh(etat_courant[68]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_hat_operator_etat_puits_huh(etat_courant[69]);
      tous_les_automates_sont_bloques_huh &= lexer_lexer_for_c_language_automaton_token_assign_pipe_operator_etat_puits_huh(etat_courant[70]);
    }
    
    
    if (tous_les_automates_sont_bloques_huh) break;
  }
  
  
  if (-1 == indice_automate_ayant_reconnu_le_plus_long_prefixe) {
    return (0 != 0);
  }
  
  
  lexer_lexer_for_c_language_token_type_t type;
  switch (indice_automate_ayant_reconnu_le_plus_long_prefixe) {
    default: assert(0 != 0); break;
    case 0: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BLANK; break;
    case 1: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_MULTILINES; break;
    case 2: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMENT_ONELINE_CPP; break;
    case 3: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MONO_LINE; break;
    case 4: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIRECTIVE_MULTI_LINES; break;
    case 5: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_IDENT; break;
    case 6: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_ZERO; break;
    case 7: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC; break;
    case 8: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_DEC_V2; break;
    case 9: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_HEX; break;
    case 10: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_BIN; break;
    case 11: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VCC; break;
    case 12: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INTEGER_OCT_VC; break;
    case 13: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_SIMPLE; break;
    case 14: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_DEC_WITH_EXP; break;
    case 15: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_REAL_HEX_WITH_EXP; break;
    case 16: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE; break;
    case 17: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_SIMPLE_NEWLINE; break;
    case 18: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_EMPTY; break;
    case 19: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_ESCAPE; break;
    case 20: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CHAR_WIDE; break;
    case 21: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING; break;
    case 22: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_ENDED_BY_NEWLINE; break;
    case 23: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE; break;
    case 24: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STRING_WIDE_ENDED_BY_NEWLINE; break;
    case 25: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_PAR; break;
    case 26: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_PAR; break;
    case 27: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACKET; break;
    case 28: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACKET; break;
    case 29: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_OPEN_BRACE; break;
    case 30: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_CLOSE_BRACE; break;
    case 31: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COMMA; break;
    case 32: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_POINT_OPERATOR; break;
    case 33: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ARROW_OPERATOR; break;
    case 34: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SEMICOLON; break;
    case 35: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_STAR_OPERATOR; break;
    case 36: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_OPERATOR; break;
    case 37: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_OPERATOR; break;
    case 38: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RDIV_OPERATOR; break;
    case 39: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_TILDE_OPERATOR; break;
    case 40: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PERLUETE_OPERATOR; break;
    case 41: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PERLUETE_OPERATOR; break;
    case 42: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SIMPLE_PIPE_OPERATOR; break;
    case 43: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DOUBLE_PIPE_OPERATOR; break;
    case 44: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_EQUAL_HUH_OPERATOR; break;
    case 45: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HAT_OPERATOR; break;
    case 46: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PERCENT_OPERATOR; break;
    case 47: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_BANG_OPERATOR; break;
    case 48: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_DIFFERENT_HUH_OPERATOR; break;
    case 49: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OPERATOR; break;
    case 50: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OPERATOR; break;
    case 51: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_INF_OR_EQUAL_OPERATOR; break;
    case 52: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_SUP_OR_EQUAL_OPERATOR; break;
    case 53: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_PLUS_PLUS_OPERATOR; break;
    case 54: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_MINUS_MINUS_OPERARTOR; break;
    case 55: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_LSHIFT_OPERATOR; break;
    case 56: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_RSHIFT_OPERATOR; break;
    case 57: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_HUH_OPERATOR; break;
    case 58: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_COLON_OPERATOR; break;
    case 59: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ELLIPSIS; break;
    case 60: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_OPERATOR; break;
    case 61: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_STAR_OPERATOR; break;
    case 62: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RDIV_OPERATOR; break;
    case 63: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERCENT_OPERATOR; break;
    case 64: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PLUS_OPERATOR; break;
    case 65: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_MINUS_OPERATOR; break;
    case 66: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_LSHIFT_OPERATOR; break;
    case 67: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_RSHIFT_OPERATOR; break;
    case 68: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PERLUETE_OPERATOR; break;
    case 69: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_HAT_OPERATOR; break;
    case 70: type = LEXER_LEXER_FOR_C_LANGUAGE_TOKEN_TYPE_ASSIGN_PIPE_OPERATOR; break;
  };
  
  
  *type_ptr = type;
  
  
  
  
  return (0 == 0);
}


#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>


static char * lexer_lexer_for_c_language_strcopy(const char * str);
char * lexer_lexer_for_c_language_strcopy(const char * str) {
  const size_t len = strlen(str);
  const size_t len_octet = (len+1) * (sizeof(char));
  char * retour;
  retour = (char *) malloc(len_octet);
  memcpy(retour, str, len_octet);
  return retour;
}


static char * lexer_lexer_for_c_language_int_string(int n);
char * lexer_lexer_for_c_language_int_string(int n) {
  char * retour;
  asprintf(&retour, "%d", n);
  return retour;
}


static char * lexer_lexer_for_c_language_strconcat2(const char * const str1, const char * const str2);
char * lexer_lexer_for_c_language_strconcat2(const char * const str1, const char * const str2) {
  const size_t len = strlen(str1) + strlen(str2);
  return strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2);
}


static char * lexer_lexer_for_c_language_strconcat3(const char * const str1, const char * const str2, const char * const str3);
char * lexer_lexer_for_c_language_strconcat3(const char * const str1, const char * const str2, const char * const str3) {
  const size_t len = strlen(str1) + strlen(str2) + strlen(str3);
  return strcat(strcat(strcpy(malloc((len + 1)*(sizeof(char))), str1), str2), str3);
}


static void lexer_lexer_for_c_language_stradd2(char * * str0, const char * str1);
void lexer_lexer_for_c_language_stradd2(char * * str0, const char * str1) {
  char * temp;
  temp = lexer_lexer_for_c_language_strconcat2(*str0, str1);
  free(*str0);
  *str0 = temp;
}


static void lexer_lexer_for_c_language_stradd3(char * * str0, const char * str1, const char * str2);
void lexer_lexer_for_c_language_stradd3(char * * str0, const char * str1, const char * str2) {
  char * temp;
  temp = lexer_lexer_for_c_language_strconcat3(*str0, str1, str2);
  free(*str0);
  *str0 = temp;
}


static char * lexer_lexer_for_c_language_substring(const char * str, unsigned int debut, unsigned int fin);
char * lexer_lexer_for_c_language_substring(const char * str, unsigned int debut, unsigned int fin) {
  size_t len;
  size_t taille_octet;
  char * retour;
  assert(debut <= fin);
  len = fin - debut;
  taille_octet = (len + 1) * (sizeof (char));
  retour = (char *) malloc(taille_octet);
  memcpy(retour, str + debut, taille_octet);
  retour[len] = '\0';
  return retour;
}







lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_analyse_de_la_ligne(const char * mot, int * nb_lettres_qui_ont_ete_reconnues_ptr) {
  int longueur_du_plus_long_prefixe_reconnu;
  int plus_long_prefixe_reconnu_huh;
  //int indice_de_l_automate_ayant_reconnu_le_plus_long_prefixe;
  lexer_lexer_for_c_language_token_type_t type_du_le_plus_long_prefixe_reconnu;
  int nb_lettres_deja_reconnues;
  lexer_lexer_for_c_language_token_liste_t * tokens;
  
  tokens = lexer_lexer_for_c_language_token_liste_vide();
  
  
  for (nb_lettres_deja_reconnues = 0; mot[nb_lettres_deja_reconnues] != '\0'; nb_lettres_deja_reconnues += longueur_du_plus_long_prefixe_reconnu) {
    plus_long_prefixe_reconnu_huh = type_du_plus_long_prefixe_reconnu(&(mot[nb_lettres_deja_reconnues]), &type_du_le_plus_long_prefixe_reconnu, &longueur_du_plus_long_prefixe_reconnu);
    
    if (!(plus_long_prefixe_reconnu_huh)) {
      break;
    }
    
    {
      char * lexeme = NULL;
      lexer_lexer_for_c_language_token_t * token;
      lexeme = lexer_lexer_for_c_language_substring(mot, nb_lettres_deja_reconnues, nb_lettres_deja_reconnues + longueur_du_plus_long_prefixe_reconnu);
      token = lexer_lexer_for_c_language_token_make_nocopy(type_du_le_plus_long_prefixe_reconnu, lexeme);
      tokens = lexer_lexer_for_c_language_token_liste_cons(token, tokens);
    }
  }
  
  lexer_lexer_for_c_language_token_liste_reverse_surplace(&tokens);
  
  *nb_lettres_qui_ont_ete_reconnues_ptr = nb_lettres_deja_reconnues;
  
  return tokens;
}






#include <strings.h>


static char * lexer_lexer_for_c_language_readline(void);


char * lexer_lexer_for_c_language_readline(void) {
  char buffer[1024];
  {
    bzero(buffer, 1024 * (sizeof(char)));
    for (int i = 0; i < 1024; i++) {
      size_t nb_read;
      nb_read = fread(&(buffer[i]), 1, 1, stdin);
      if (buffer[i] == '\n') break;
    }
  }
  char * retour;
  {
    const size_t len = strlen(buffer);
    const size_t len_octet = (len+1) * (sizeof(char));
    retour = (char *) malloc(len_octet);
    memcpy(retour, buffer, len_octet);
  }
  return retour;
}






#include <string.h>


static void lexer_lexer_for_c_language_read_eval_print_loop(void);

void lexer_lexer_for_c_language_read_eval_print_loop(void) {
  char * mot;
  const char * prompt = "> ";
  
  printf("Starting read-eval-print loop (type 'quit', 'exit', 'bye', or 'stop' to quit).\n");
  
  for (;;) {
    printf("%s", prompt);
    mot = lexer_lexer_for_c_language_readline();
    
    {
      int quit_huh;
      quit_huh = (0 != 0); 
      quit_huh |= (0 == strcmp(mot, ""));
      quit_huh |= (0 == strcmp(mot, "quit\n"));
      quit_huh |= (0 == strcmp(mot, "bye\n"));
      quit_huh |= (0 == strcmp(mot, "exit\n"));
      quit_huh |= (0 == strcmp(mot, "stop\n"));
      quit_huh |= (0 == strcmp(mot, "quit"));
      quit_huh |= (0 == strcmp(mot, "bye"));
      quit_huh |= (0 == strcmp(mot, "exit"));
      quit_huh |= (0 == strcmp(mot, "stop"));
      if (quit_huh) break;
    }
    
    lexer_lexer_for_c_language_token_liste_t * tokens = NULL;
    int nb_lettres_qui_ont_ete_reconnues = -1;
    tokens = lexer_lexer_for_c_language_analyse_de_la_ligne(mot, &nb_lettres_qui_ont_ete_reconnues);
    printf("%s\n", lexer_lexer_for_c_language_token_liste_string(tokens));
    
    if (mot[nb_lettres_qui_ont_ete_reconnues] != '\0') {
      fputs("Unfortunately, there were letters on the line that were not recognized: '", stdout);
      fputs(&mot[nb_lettres_qui_ont_ete_reconnues], stdout);
      fputs("'.", stdout);
      fputs("\n", stdout);
    }
    
  }
  
  fputs("Bye!\n", stdout);
}





#include <string.h>



lexer_lexer_for_c_language_token_liste_t * lexer_lexer_for_c_language_do_the_job_bang(const char * mot) {
  if (NULL == mot) return NULL;
  
  lexer_lexer_for_c_language_token_liste_t * tokens = NULL;
  int nb_lettres_qui_ont_ete_reconnues = -1;
  tokens = lexer_lexer_for_c_language_analyse_de_la_ligne(mot, &nb_lettres_qui_ont_ete_reconnues);
  if (mot[nb_lettres_qui_ont_ete_reconnues] != '\0') {
  lexer_lexer_for_c_language_token_liste_free(tokens);
    return NULL;
  }
  
  return tokens;
}



#ifdef LEXER_LEXER_FOR_C_LANGUAGE_USE_MAIN_FUNCTION


int main(int argc, char * argv[]) {
  
  printf("Hello! I will try to match the text you type with the following regular expressions:\n");
  printf("\t%s\n", "BLANK:[ \\n\\r\\t\\v\\f]+");
  printf("\t%s\n", "COMMENT_MULTILINES:/\\*!(.*\\*/.*)\\*/");
  printf("\t%s\n", "COMMENT_ONELINE_CPP://!(.*\\n.*)\\n");
  printf("\t%s\n", "DIRECTIVE_MONO_LINE:#!(.*\\n.*)\\n");
  printf("\t%s\n", "DIRECTIVE_MULTI_LINES:#!(.*\\n.*)(\\\\\\n!(.*\\n.*))*\\n");
  printf("\t%s\n", "IDENT:[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_][abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_1234567890]*");
  printf("\t%s\n", "INTEGER_ZERO:0+");
  printf("\t%s\n", "INTEGER_DEC:[123456789]+[1234567890]*[uU]?[lL]?[lL]?");
  printf("\t%s\n", "INTEGER_DEC_v2:0[dD][1234567890]+");
  printf("\t%s\n", "INTEGER_HEX:0[xX][1234567890ABCDEFabcdef]+");
  printf("\t%s\n", "INTEGER_BIN:0[bB][10]+");
  printf("\t%s\n", "INTEGER_OCT_vCC:0[oO][12345670]+");
  printf("\t%s\n", "INTEGER_OCT_vC:0+[1234567]+[12345670]*");
  printf("\t%s\n", "REAL_DEC_SIMPLE:[([1234567890]+\\.[1234567890]*)([1234567890]*\\.[1234567890]+)]([fFlL]?)");
  printf("\t%s\n", "REAL_DEC_WITH_EXP:[([1234567890]+\\.[1234567890]*)([1234567890]*\\.[1234567890]+)([1234567890]+)]([eE][\\+\\-]?[1234567890]+)([fFlL]?)");
  printf("\t%s\n", "REAL_HEX_WITH_EXP:0[xX][([1234567890ABCDEFabcdef]+\\.[1234567890ABCDEFabcdef]*)([1234567890ABCDEFabcdef]*\\.[1234567890ABCDEFabcdef]+)([1234567890ABCDEFabcdef]+)]([pP][\\+\\-]?[1234567890]+)([fFlL]?)");
  printf("\t%s\n", "CHAR_SIMPLE:('{!['\\n\\\\].}')");
  printf("\t%s\n", "CHAR_SIMPLE_NEWLINE:('\\n')");
  printf("\t%s\n", "CHAR_EMPTY:('')");
  printf("\t%s\n", "CHAR_ESCAPE:('\\\\.')");
  printf("\t%s\n", "CHAR_WIDE:L[('{.!{'\\n\\\\}}')('\\\\.')]");
  printf("\t%s\n", "STRING:\"!(.*[\"\\n\\\\].*)(\\\\.!(.*[\"\\n\\\\].*))*\"");
  printf("\t%s\n", "STRING_ENDED_BY_NEWLINE:\"!(.*[\"\\n\\\\].*)(\\\\.!(.*[\"\\n\\\\].*))*\\n");
  printf("\t%s\n", "STRING_WIDE:L\"!(.*[\"\\n\\\\].*)(\\\\.!(.*[\"\\n\\\\].*))*\"");
  printf("\t%s\n", "STRING_WIDE_ENDED_BY_NEWLINE:L\"!(.*[\"\\n\\\\].*)(\\\\.!(.*[\"\\n\\\\].*))*\\n");
  printf("\t%s\n", "OPEN_PAR:\\(");
  printf("\t%s\n", "CLOSE_PAR:\\)");
  printf("\t%s\n", "OPEN_BRACKET:\\[");
  printf("\t%s\n", "CLOSE_BRACKET:\\]");
  printf("\t%s\n", "OPEN_BRACE:\\{");
  printf("\t%s\n", "CLOSE_BRACE:\\}");
  printf("\t%s\n", "COMMA:,");
  printf("\t%s\n", "POINT_OPERATOR:\\.");
  printf("\t%s\n", "ARROW_OPERATOR:->");
  printf("\t%s\n", "SEMICOLON:;");
  printf("\t%s\n", "STAR_OPERATOR:\\*");
  printf("\t%s\n", "PLUS_OPERATOR:\\+");
  printf("\t%s\n", "MINUS_OPERATOR:-");
  printf("\t%s\n", "RDIV_OPERATOR:/");
  printf("\t%s\n", "TILDE_OPERATOR:~");
  printf("\t%s\n", "SIMPLE_PERLUETE_OPERATOR:&");
  printf("\t%s\n", "DOUBLE_PERLUETE_OPERATOR:&&");
  printf("\t%s\n", "SIMPLE_PIPE_OPERATOR:|");
  printf("\t%s\n", "DOUBLE_PIPE_OPERATOR:||");
  printf("\t%s\n", "EQUAL_HUH_OPERATOR:==");
  printf("\t%s\n", "HAT_OPERATOR:^");
  printf("\t%s\n", "PERCENT_OPERATOR:%");
  printf("\t%s\n", "BANG_OPERATOR:\\!");
  printf("\t%s\n", "DIFFERENT_HUH_OPERATOR:\\!=");
  printf("\t%s\n", "INF_OPERATOR:<");
  printf("\t%s\n", "SUP_OPERATOR:>");
  printf("\t%s\n", "INF_OR_EQUAL_OPERATOR:<=");
  printf("\t%s\n", "SUP_OR_EQUAL_OPERATOR:>=");
  printf("\t%s\n", "PLUS_PLUS_OPERATOR:\\+\\+");
  printf("\t%s\n", "MINUS_MINUS_OPERARTOR:--");
  printf("\t%s\n", "LSHIFT_OPERATOR:<<");
  printf("\t%s\n", "RSHIFT_OPERATOR:>>");
  printf("\t%s\n", "HUH_OPERATOR:\\?");
  printf("\t%s\n", "COLON_OPERATOR:\\:");
  printf("\t%s\n", "ELLIPSIS:\\.\\.\\.");
  printf("\t%s\n", "ASSIGN_OPERATOR:=");
  printf("\t%s\n", "ASSIGN_STAR_OPERATOR:\\*\\=");
  printf("\t%s\n", "ASSIGN_RDIV_OPERATOR:\\/\\=");
  printf("\t%s\n", "ASSIGN_PERCENT_OPERATOR:\\%\\=");
  printf("\t%s\n", "ASSIGN_PLUS_OPERATOR:\\+\\=");
  printf("\t%s\n", "ASSIGN_MINUS_OPERATOR:\\-\\=");
  printf("\t%s\n", "ASSIGN_LSHIFT_OPERATOR:\\<\\<\\=");
  printf("\t%s\n", "ASSIGN_RSHIFT_OPERATOR:\\>\\>\\=");
  printf("\t%s\n", "ASSIGN_PERLUETE_OPERATOR:\\&\\=");
  printf("\t%s\n", "ASSIGN_HAT_OPERATOR:\\^\\=");
  printf("\t%s\n", "ASSIGN_PIPE_OPERATOR:\\|\\=");
  
  
  
  
  
  lexer_lexer_for_c_language_read_eval_print_loop();
  
  
  
  
  return 0;
}


#endif /* LEXER_LEXER_FOR_C_LANGUAGE_USE_MAIN_FUNCTION */ 




