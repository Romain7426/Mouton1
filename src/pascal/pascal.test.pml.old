{ Les scripts ne reconnaissent que ce type de commentaire. C'est évoluable si nécessaire. }
{ Le langage ne connait le truc program ou unit ou debut.
Normal cela ne sert à rien.
S'il est mis, cela fera une erreur de parsing.}
{program pascal_ocaml_test;}


{ Ensuite, comme d'habitude, il y a un fichier de sortie de l'analyse lexicale. }
{ S'y rapporter en cas de soucis. }


{
Le langage est très proche du pascal dans la forme.
Néanmoins, il est beaucoup plus typé, dont on a pris l'exemple sur OCaml
( =, <, etc., polymorphe, mais pas +, +., etc.).
Aussi, pour les idents, on a pris l'exemple de Scheme,
qui reconnait vraiment un nombre impressionnant de machin.
Pour être sûr que nous reconnaissons tout bien,
on ne reconnait pas autant de chose, mais on reconnait n'importe quoi comme ident.
En fait, une erreur de lexing est impossible.
Par contre une erreur de parsing l'est très nettement moins.
}

{
Un fichier Pascal OCaml Script de ZEmacs|Zeldacs,
est une suite de déclarations :
des constantes,
des types,
des variables,
des procédures,
et des fonctions.
Par défaut (seul mode), tous les éléments d'un fichier sont accessible de l'extérieur.
Le fichier est comme un module.
Seules les variables locales ne seront pas accessibles de l'extérieur.
}

{
Regardez c beau !
}

const
   Néééàà@@@~À|&°ç = 90;
   N		   = 23;
   M		   = 3 * N + 2;
		   
type
   TypeElement = integer;
   liste       = ^cellule;
   cellule     = record
		    contenu : TypeElement;
		    suivant : liste;
		 end;	    
   waza	       = array[1..{N}23] of liste;
		 

procedure raz(var l : liste);
begin
   l := nil
end; { raz }

{ Y a des trucs ici qui font planter le parser. }

function mp(a:TypeElement; l:liste):liste;
var p : liste;
begin 
   new(p);
{ L'opérateur '.' n'est pas encore supporté, ce qui cause une seg fault. :-) }
   
   p^.contenu := a;
   p^.suivant := l;
   
   mp := p
end; { mp }

begin
   writeln('machin')
end
var l, ll, lll, llll : liste;
   x, y, z	     : real;
   a,b,c	     : integer;
   bool		     : boolean;
   str		     : string;
   ptr		     : ^real;
var N : real;
   a  : array[1..23] of ^string;
   b  : array[0..99] of array[3..65] of ^array[65..12] of boolean;



procedure proc(var a : integer);
var n : integer;
begin
   {proc(a);}
   n := (a div 2) * 2 + a mod 2;
   writeln('Appel à proc -> a = ', a, ' et n = ', n);
   a := a + 1
end;

function inc(n : integer):integer;
begin
   writeln('LA');
   inc := n + 1;
   writeln(inc);
   {inc := inc(n)}
end; { inc }
function fact(n	: integer):integer;
begin
   if n <= 1 then fact := 1
   else fact := n * fact(n - 1)
   end
end;
begin
   writeln('Bonjour.');
   ;
   writeln();
   writeln('Au revoir.', 'C était Romain.');
   writeln(1,2,3,4,5,6,7,8,9,0);
   { Pas des reels.
   writeln(.1,.2,.3,.4,.5,.6,.7,.8,.9,.0);
   writeln(1.,2.,3.,4.,5.,6.,7.,8.,9.,0.);
   }
   writeln(1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,0.0);

   writeln(1 + 2 + 3 + 4 + 5, true and false and true and true);
   writeln(false or false or true or false or false or false);
   writeln(1 = 2, true = true, 1 = 1, false = false, true = false, false = true);
   writeln(1.0 <> 1.0, 1.1 = 1.1);
   writeln(1.0 +. 2.0 +.3.0+.4.0+.5.0);
   writeln(1.0 < 2.0, 1.0 > 2.0, 1.0 <= 2.0, 1.0 >= 2.0);
   writeln(1-2, 1.0-.2.0);
   writeln(1*2,1.0*.2.0);
   writeln(1 div 2, 1 mod 2, 1.0 /. 2.0);
   writeln(not true, not false);
   writeln(+1,-1,+.1.0,-.1.0);
   writeln(2 * ( 1 + 1), 2 * 1 + 1, 2 * 1 + 1 = 2 * (1 + 1));
   if false then
      writeln( ident, true, false, tre^, not true, +1 , -0, -.0.0,+.123.132 );
      write(tab[i]);
   end;
   if true then
      writeln('Bouh')
   else
      writeln('teille')
   end;
   if false then
      writeln('Bouh')
   else
      writeln('teille')
   end;
begin
   writeln('BEGIN');
   for i := 1 to 10 do write('for');
   writeln('BEGIN');
   repeat
      write('repeat');
      read();
      readln()
   until false;
   while false do writeln('merde');
   N := 1.0;
   while N < 1000000000000000000.0 do begin write('boucle', N); N := N *. 2.0 end;
   writeln('M = ', M);
   writeln(ptr, ptr^);
   new(ptr);
   writeln(ptr, ptr^);
   ptr^ := 23.0;
   writeln(ptr^);
   writeln(nil, nil^);
   writeln('-------------------------------------------------');
   c := 5676;
   writeln(c);
   proc(c);
   writeln(c,inc(c),c);
   writeln('fact(10) = ', fact(10))
end;
 

end { Les }

