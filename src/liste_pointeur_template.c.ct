//"#include \"global.h\"\n"
//"#include \"@.h\"\n"
//"#include \"@_liste.h\"\n"
"\n"
//"//#pragma message \"Compiling \" __FILE__ \"...\"\n"
"\n"
//"//#pragma GCC diagnostic ignored \"-Waggregate-return\"\n"
"\n"
"\n"
"static @_liste_t * @_liste_allouer(void);\n"
"\n"
"\n"
"static void @_liste_reverse_aux(const @_liste_t * l, @_liste_t * * accu);\n"
"\n"
"\n"
"\n"
"@_liste_t * @_liste_vide(void) {\n"
"  return NULL;\n"
"}\n"
"\n"
"int @_liste_vide_huh(const @_liste_t * l) {\n"
"  return (NULL == l);\n"
"}\n"
"\n"
"@_liste_t * @_liste_allouer(void) {\n"
"  return (@_liste_t *) malloc(sizeof (@_liste_t));\n"
"}\n"
"\n"
"@_liste_t * @_liste_cons(const @_t * a, const @_liste_t * l) {\n"
"  return @_liste_cons_nocopy(@_copy(a), @_liste_copy(l));\n"
"}\n"
"\n"
"@_liste_t * @_liste_cons_nocopy(@_t * a, @_liste_t * l) {\n"
"  @_liste_t * retour;\n"
"  retour = @_liste_allouer();\n"
"  retour -> car = a;\n"
"  retour -> cdr = l;\n"
"  return retour;\n"
"}\n"
"\n"
"void @_liste_free(@_liste_t * l) {\n"
"  if (l == NULL) return;\n"
"  @_free(l -> car);\n"
"  @_liste_free(l -> cdr);\n"
"  free(l);\n"
"}\n"
"\n"
"void @_liste_free_nocopy(@_liste_t * l) {\n"
"  if (l == NULL) return;\n"
"  @_liste_free_nocopy(l -> cdr);\n"
"  free(l);\n"
"}\n"
"\n"
"@_liste_t * @_liste_copy(const @_liste_t * l) {\n"
"  if (l == NULL) \n"
"    return NULL;\n"
"  \n"
"  return @_liste_cons(l -> car, l -> cdr);\n"
"}\n"
"\n"
"int @_liste_longueur(const @_liste_t * l) {\n"
"  if (l == NULL) {\n"
"    return 0;\n"
"  }\n"
"  \n"
"  return 1 + @_liste_longueur(l -> cdr);\n"
"}\n"
"\n"
"\n"
"#if 0\n"
"@_liste_t * @_liste_vlist(int n, va_list args) {\n"
"  int i;\n"
"  @_liste_t * retour;\n"
"  @_liste_element_t temp;\n"
"\n"
"  retour = @_liste_vide();\n"
"  \n"
"  for (i = 0; i < n; i++) {\n"
"    temp = va_arg(args, @_liste_element_t);\n"
"    retour = @_liste_cons_element(temp, retour);\n"
"  }\n"
"\n"
"  @_liste_reverse_surplace(&retour);\n"
"\n"
"  return retour;\n"
"}\n"
"\n"
"@_liste_t * @_liste_list(int n, ...) {\n"
"  va_list args;\n"
"  @_liste_t * retour;\n"
"\n"
"  va_start(args, n);\n"
"  retour = @_liste_vlist(n, args);\n"
"  va_end(args);\n"
"\n"
"  return retour;\n"
"}\n"
"#endif\n"
"\n"
"\n"
"int @_liste_equal(const @_liste_t * l1, const @_liste_t * l2) {\n"
"  int b1;\n"
"  int b2;\n"
"  int b3;\n"
"\n"
"  b1 = @_liste_vide_huh(l1);\n"
"  b2 = @_liste_vide_huh(l2);\n"
" \n"
"  if (b1) {\n"
"    return b2;\n"
"  }\n"
"\n"
"  if (b2) {\n"
"    return (0 != 0);\n"
"  }\n"
"\n"
"  b3 = @_equal(l1 -> car, l2 -> car);\n"
"  if (b3) {\n"
"    return @_liste_equal(l1 -> cdr, l2 -> cdr);\n"
"  }\n"
"  else {\n"
"    return (0 != 0);\n"
"  }\n"
"\n"
"  assert(0 != 0);\n"
"  return (0 != 0);\n"
"}\n"
"\n"
"\n"
"\n"
"int @_liste_member(const @_t * a, const @_liste_t * liste) {\n"
"  int b;\n"
"\n"
"  b = @_liste_vide_huh(liste);\n"
"\n"
"  if (b) return (0 != 0);\n"
"\n"
"  b = @_equal(a, liste -> car);\n"
"\n"
"  if (b) return (0 == 0);\n"
"\n"
"  return @_liste_member(a, liste -> cdr);\n"
"}\n"
"\n"
"\n"
"int @_liste_member_iteratif(const @_t * a, const @_liste_t * liste) {\n"
"  while (!(@_liste_vide_huh(liste))) {\n"
"    if (@_equal(a, liste -> car)) return (0 == 0); \n"
"\n"
"    liste = liste -> cdr;\n"
"  }\n"
"\n"
"  return (0 != 0);\n"
"}\n"
" \n"
" \n"
"@_t * @_liste_pop(@_liste_t * * l) {\n"
"  assert(l != NULL);\n"
"  assert(*l != NULL);\n"
"\n"
"  @_t * a;\n"
"  @_liste_t * p;\n"
"\n"
"  a = (*l) -> car;\n"
"  p = (*l) -> cdr;\n"
"  \n"
"  free(*l);\n"
"\n"
"  *l = p;\n"
"\n"
"  return a;\n"
"}\n"
"\n"
"\n"
"@_liste_t * @_liste_map(@_t * (* f)(const @_t *), const @_liste_t * l) {\n"
"  if (l == NULL) return NULL;\n"
"\n"
"  return @_liste_cons_nocopy(f(l -> car), @_liste_map(f, l -> cdr));\n"
"}\n"
"\n"
"\n"
"@_t * @_liste_fold(@_t * (* f)(const @_t *, const @_t *), const @_t * a, const @_liste_t * l) {\n"
"  if (l == NULL) return @_copy(a);\n"
"  \n"
"  return f(l -> car, @_liste_fold(f, a, l -> cdr));\n"
"}\n"
"\n"
"\n"
"char * @_liste_string(const @_liste_t * l) {\n"
"  char * retour;\n"
"  int n;\n"
"  int i;\n"
"  char * prec;\n"
"  char * str;\n"
"\n"
"  n = @_liste_longueur(l);\n"
"\n"
"  if (n == 0) {\n"
"    const char * const u = \"list []\";\n"
"    //retour = strcopy(\"list []\");\n"
"    return strcpy(malloc(strlen(u)+1), u);\n"
"  }\n"
"\n"
//"  retour = strcopy(\"list [\");\n"
"  retour = @_liste_strcopy(\"list [\");\n"
"\n"
"  assert(n >= 1);\n"
"  for (i = 0; i < n - 1; i++) {\n"
"    prec = retour;\n"
"    str = @_string(l -> car);\n"
"    retour = @_liste_strconcat3(prec, str, \", \");\n"
"    free(str);\n"
"    free(prec);\n"
"    l = l -> cdr;\n"
"  }\n"
"\n"
"  prec = retour;\n"
"\n"
"  str = @_string(l -> car);\n"
"  retour = @_liste_strconcat2(prec, str);\n"
"  free(str);\n"
"  free(prec);\n"
"  prec = retour;\n"
"\n"
"  retour = @_liste_strconcat2(prec, \"]\");\n"
"  free(prec);\n"
"\n"
"  return retour;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"@_liste_t * @_liste_reverse(const @_liste_t * l) {\n"
"  @_liste_t * retour;\n"
"\n"
"  retour = NULL;\n"
"  @_liste_reverse_aux(l, &retour);\n"
"\n"
"  return retour;\n"
"}\n"
"\n"
"void @_liste_reverse_aux(const @_liste_t * l, @_liste_t * * accu) {\n"
"  if (l == NULL) {\n"
"    return;\n"
"  }\n"
"\n"
"  *accu = @_liste_cons_nocopy(@_copy(l -> car), *accu);\n"
"\n"
"  @_liste_reverse_aux(l -> cdr, accu);\n"
"}\n"
"\n"
"\n"
"void @_liste_reverse_surplace(@_liste_t * * liste) {\n"
"  assert(liste != NULL);\n"
"  @_liste_t * precedent;\n"
"  @_liste_t * courant;\n"
"  @_liste_t * suivant;\n"
"\n"
"  if (@_liste_vide_huh(*liste)) return;\n"
"\n"
"  precedent = @_liste_vide();\n"
"  courant = *liste;\n"
"  suivant = courant -> cdr;\n"
"\n"
"  while (!(@_liste_vide_huh(suivant))) {\n"
"    courant -> cdr = precedent;\n"
"\n"
"    precedent = courant;\n"
"    courant = suivant;\n"
"    suivant = suivant -> cdr;\n"
"  }\n"
"\n"
"  courant -> cdr = precedent;\n"
"\n"
"  *liste = courant;\n"
"}\n"
"\n"
"\n"
"\n"
"@_liste_t * @_liste_append(const @_liste_t * l, const @_liste_t * m) {\n"
"  if (l == NULL) return @_liste_copy(m);\n"
"\n"
"  return @_liste_cons_nocopy(@_copy(l -> car), @_liste_append(l -> cdr, m));\n"
"}\n"
"\n"
"void @_liste_append_nocopy(@_liste_t * * l, @_liste_t * m) {\n"
"  if (*l == NULL) {\n"
"    *l = m;\n"
"    return;\n"
"  }\n"
"  \n"
"  @_liste_append_nocopy(&((*l) -> cdr), m);\n"
"}\n"
"\n"
"\n"
"int @_liste_count(const @_t * a, const @_liste_t * l) {\n"
"  if (l == NULL) return 0;\n"
"  int s, t;\n"
"  s = (@_equal(a, l->car)) ? 1 : 0;\n"
"  t = @_liste_count(a, l -> cdr);\n"
"  return s + t;\n"
"}\n"
"\n"
""

