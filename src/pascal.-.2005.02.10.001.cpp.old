#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "pascal.hpp"


/* La fonction de comparaison de deux types. */
bool ptype_equal(ptype a, ptype b)
{
     if (a.nature != b.nature)
        return false;
        
     switch (a.nature)
     {
            case PTNBase: 
                 return (a.t.base == b.t.base);
                 break;
            case PTNConstruit: 
                 SPConstruit aa = a.t.constuit, bb = b.t.construit;
                 UPConstruit aaa = aa.upcons, bbb = bb.upcons;
                 if (aa.ptc != bb.ptc)
                    return false;
                 switch (aa.ptc)
                 {
                        case PTCSubrange: 
                             return (aaa.s == bbb.s);
                             break;
                        case PTCArray: 
                             if (aaa.a.indice != bbb.a.indice)
                                return false;
                             return ptype_equal(*(aaa.a.telement), *(bbb.a.telement));
                             break;
                        case PTCPointer: 
                             return ptype_equal(*(aaa.p.telement), *(bbb.p.telement));
                             break;
                        case PTCRecord:
                             lchamps *la = aaa.r.champs, *lb = bbb.r.champs;
                             bool b;

                             if (la == NULL)
                                return (lb == NULL);
                             if (lb == NULL)
                                return false;
                                
                             do 
                             {
                                b = (strcmp(la->nchamp, lb->nchamp) == 0);
                                if (!b)
                                   return false;
                                b = ptype_equal(*(la->tchamp), *(lb->tchamp));
                                if (!b)
                                   return false;
                                la = la->schamp;
                                lb = lb->schamp;
                                if (la == NULL)
                                   return (lb == NULL);
                                if (lb == NULL)
                                   return false;
                             } while (true);
                             break;
                        case PTCFunction:
                             if (!(ptype_equal(*(aaa.func.retour), *(bbb.func.retour))))
                                return false;
                        case PTCProcedure: 
                             lparams *la = aaa.proc.params, *lb = bbb.proc.params;
                             bool b;

                             if (la == NULL)
                                return (lb == NULL);
                             if (lb == NULL)
                                return false;
                                
                             do 
                             {
                                b = ptype_equal(*(la->tparam), *(lb->tparam));
                                if (!b)
                                   return false;
                                la = la->sparam;
                                lb = lb->sparam;
                                if (la == NULL)
                                   return (lb == NULL);
                                if (lb == NULL)
                                   return false;
                             } while (true);
                             break;
                        default:
                                //messerr("Impossible de déterminer l'égalité des types construits, car ils sont inconnus.");
                                return false;
                 }
                 break;
            default:
                    //messerr("Impossible de déterminer si les types sont égaux. Ils sont inconnus.");
                    return false;
     }
}








/* La fonction d'ajout d'un élément dans l'environnement. */
TEnvironnement update(TEnvironnement env, char *ident, pdval val) 
{
               if (ident == NULL) 
               {
                  //messerr("Impossible d'ajouter l'ident dans l'environnement car c'est un pointeur null.");
                  return env;
               }
               
               TEnvironnement temp = new TEnvironnement;
               *temp = val;
               temp->nom = new char[strlen(ident)];
               strcpy(temp->nom, ident);
               temp->suivant = env;
               return temp;
};
               


/* La fonction de recherche dans l'environnement.
   //La fonction retourne l'indice de l'élément dans le tableau,
   //sinon, un nombre négatif correspondant à un code d'erreur.
   La valeur retournée est un code d'erreur.
   Sinon la valeur de retour est dans val.
*/
int envlookup(TEnvironnement env, char *ident, pdval &val)
{
    //message("Recherche dans l'environnement l'identifiant '%s'.", ident);
    
    if (ident == NULL)
    {
       //messerr("'ident' est NULL ==> DTC");
       return -1;
    }
    
    if (env == NULL)
    {
       //meserr("'ident' \"%s\" n'a pas été trouvé dans l'environnement.", ident);
       return -2;
    }
    
    if (strcmp(env->nom, ident) == 0)
    {
       //message("'ident' a étét trouvé dans l'environnement.");
       val = *env;
       return 0;
    }
    
    return envlookup(env->suivant, ident, val);
    /*
    int i = 0;
    while (i < MAX_ENVIRONNEMENT)
    {
          if (strcmp(env[i].nom,ident) == 0) break;
    }
    
    if (i >= MAX_ENVIRONNEMENT)
    {
       //messerr("identifiant \"%s\" n'est pas défini.", ident);
       return -2;
    }
    else
    {
        //message("identifiant trouvé. i = %d", i);
        return i;
    }
    */
}   





/* La fonction malloc sur la memoire.
   Renvoie 0 si tout s'est bien passé,
   un truc négatif sinon.
   -1 : not enough memory
*/
int pnew(unsigned int taille, pvpointer &a)
{
    //message("Demande d'allocation de mémoires de %u cases. Mémoire disponible : %u cases. Mémoire totale : %u cases.", taille, MAX_MEMOIRE - mem_nbelts, MAXMEMOIRE);
    /* On fait la vérification dans ce sens là pour être sûr que le résultat
       soit valide. */
    if (taille > (MAX_MEMOIRE - mem_nbelts))
    {
               //messerr("Erreur à l'exécution d'un script : demande d'allocation de mémoire de %u cases, alors qu'il restait %u cases mémoires. Mémoire totale disponible : %u.", taille, MAX_MEMOIRE - mem_nbelts, MAX_MEMOIRE);
               return -1;
    }

    a = (pvpointer) mem_nbelts;
    mem_nbelts += taille;
    //message("Allocation réussie à l'adresse %d.", a);
    return 0;
}



















/* Renvoie un code d'erreur.
   0 oki
   négatif : dtc
   -1 : lors d'un ET, l'opérande de gauche n'était pas du type booléen ;
   -2 : lors d'un ET, l'opérande de droite n'était pas du type booléen ;
*/
/*
enum pascal_expression {PEt, POu, PEqual, PDiff, PInf, PSup, PInfEq, PSupEq, \
     PPlus, PMoins, PMult, PDiv, PMod, PNot, PUPlus, PUMoins, PIdent};
     + ref + ind + constante + tab
*/
int CPexpr::r_evaluate(TEnvironnement env, pval &val)
{
    pval e, e1, e2;
    int ret;
    #define VERIF_OK(a) {if ((ret = (a)) < 0){return ret;}}
    
    switch(this->t)
    {
     case PEt:
          VERIF_OK(this->expr.upet.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upet.e2->r_evaluate(env, e2));
          
          if (e1.t != PBoolean) {
             //messerr("Erreur d'évaluation d'une expression. Le membre de gauche d'un ET n'est pas de type booleen.");
             return -1;
             }

          if (e2.t != PBoolean) {
             //messerr("Erreur d'évaluation d'une expression. Le membre de droite d'un ET n'est pas de type booleen.");
             return -2;
             }
          
          val.t = PBoolean;
          val.val.b = (e1.val.b && e2.val.b);
          
          break;
          

     case POu:
          VERIF_OK(this->expr.upou.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upou.e2->r_evaluate(env, e2));
          
          if (e1.t != PBoolean) {
             //messerr("Erreur d'évaluation d'une expression. Le membre de gauche d'un OU n'est pas de type booleen.");
             return -3;
             }

          if (e2.t != PBoolean) {
             //messerr("Erreur d'évaluation d'une expression. Le membre de droite d'un OU n'est pas de type booleen.");
             return -4;
             }
          
          val.t = PBoolean;
          val.val.b = (e1.val.b || e2.val.b);
          
          break;
          

     case PEqual:
          VERIF_OK(this->expr.upequal.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upequal.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '=', les objets n'ont pas le même type.");
             return -5;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b == e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i == e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r == e2.val.r);break;
                 case PPointeur: val.val.b = (e1.val.ptr.ptr == e2.val.ptr.ptr);break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un equal, type inconnu utilisé (erreur interne)");
                  return -6;
          }
          
          break;
          


     case PDiff:
          VERIF_OK(this->expr.updiff.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.updiff.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '<>', les objets n'ont pas le même type.");
             return -7;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b != e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i != e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r != e2.val.r);break;
                 case PPointeur: val.val.b = (e1.val.ptr.ptr != e2.val.ptr.ptr);break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un diff, type inconnu utilisé (erreur interne)");
                  return -8;
          }
          
          break;
          

     case PInf:
          VERIF_OK(this->expr.upinf.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upinf.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '<', les objets n'ont pas le même type.");
             return -9;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b < e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i < e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r < e2.val.r);break;
                 case PPointeur: 
                      //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un inf, tentative de comparaison de pointeurs !!!.");
                      //val.val.b = (e1.val.ptr.ptr < e2.val.ptr.ptr);break;
                      return -10;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un inf, type inconnu utilisé (erreur interne)");
                  return -11;
          }
          
          break;
          

     case PSup:
          VERIF_OK(this->expr.upsup.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upsup.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '>', les objets n'ont pas le même type.");
             return -12;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b > e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i > e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r > e2.val.r);break;
                 case PPointeur: 
                      //val.val.b = (e1.val.ptr.ptr > e2.val.ptr.ptr);
                      //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un sup, tentative de comparaison de pointeurs !!!.");
                      return -13;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un sup, type inconnu utilisé (erreur interne)");
                  return -14;
          }
          
          break;
          



     case PInfEq:
          VERIF_OK(this->expr.upinfeq.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upinfeq.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '<=', les objets n'ont pas le même type.");
             return -15;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b <= e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i <= e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r <= e2.val.r);break;
                 case PPointeur: 
                      //val.val.b = (e1.val.ptr.ptr <= e2.val.ptr.ptr);
                      //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un infeq, tentative de comparaison de pointeurs !!!.");
                      return -16;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un infeq, type inconnu utilisé (erreur interne)");
                  return -17;
          }
          
          break;
          



     case PSupEq:
          VERIF_OK(this->expr.upsupeq.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upsupeq.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '>=', les objets n'ont pas le même type.");
             return -18;
             }

          val.t = PBoolean;
          switch (e1.t) 
          {
                 case PBoolean: val.val.b = (e1.val.b >= e2.val.b); break;
                 case PInteger: val.val.b = (e1.val.i >= e2.val.i);break;
                 case PReal: val.val.b = (e1.val.r >= e2.val.r);break;
                 case PPointeur: 
                      //val.val.b = (e1.val.ptr.ptr >= e2.val.ptr.ptr);
                      //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un supeq, tentative de comparaison de pointeurs !!!.");
                      return -19;                      
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un supeq, type inconnu utilisé (erreur interne)");
                  return -20;
          }
          
          break;
          






     case PPlus:
          VERIF_OK(this->expr.upplus.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upplus.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '+', les objets n'ont pas le même type.");
             return -21;
             }

          switch (e1.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = (e1.val.i + e2.val.i);
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = e1.val.r + e2.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un plus, addition de deux types non conformes (PTR + PTR ; BOOL + BOOL).");
                  return -22;
          }
          
          break;
          






     case PMoins:
          VERIF_OK(this->expr.upmoins.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upmoins.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '+', les objets n'ont pas le même type.");
             return -23;
             }

          switch (e1.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = (e1.val.i - e2.val.i);
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = e1.val.r - e2.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un moins, soustraction de deux types non conformes (BOOL - BOOL ; PTR - PTR).");
                  return -24;
          }
          
          break;
          








     case PMult:
          VERIF_OK(this->expr.upmult.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upmult.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un '*', les objets n'ont pas le même type.");
             return -25;
             }

          switch (e1.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = (e1.val.i * e2.val.i);
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = e1.val.r * e2.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un mult, multiplication de deux types non conformes (BOOL * BOOL ; PTR * PTR).");
                  return -26;
          }
          
          break;
          





     case PDiv:
          VERIF_OK(this->expr.updiv.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.updiv.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un 'div', les objets n'ont pas le même type.");
             return -27;
             }

          switch (e1.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = (e1.val.i / e2.val.i);
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = e1.val.r / e2.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un div, division de deux types non conformes (BOOL div BOOL ; PTR div PTR).");
                  return -28;
          }
          
          break;
          






     case PMod:
          VERIF_OK(this->expr.upmod.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.upmod.e2->r_evaluate(env, e2));
          
          if (e1.t != e2.t) {
             //messerr("Erreur d'évaluation d'une expression d'un script. De chaque côté d'un 'mod', les objets n'ont pas le même type.");
             return -29;
             }

          switch (e1.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = (e1.val.i % e2.val.i);
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un mod, calcul du reste de deux types non conformes (BOOL mod BOOL ; REAL mod REAL ; PTR mod PTR).");
                  //messerr("Toutefois, nous espérons un jour pouvoir supporter la division euclidienne sur R.");
                  return -30;
          }
          
          break;
          





     case PTab:
          VERIF_OK(this->expr.uptab.e1->r_evaluate(env, e1));
          VERIF_OK(this->expr.uptab.e2->r_evaluate(env, e2));
          /* Ce cas-ci est l'accès à un élément de tableau.
             Il faut vérifier que e1 est bien un tableau,
             puis que e2 est bien un scalaire,
             et enfin que e2 est bien dans les bornes.
             
             Ensuite seulement, on aura la valeur souhaitée.
          */
          
          if (e1.t.nature != PTNConstruit)
          {
             //messerr("Erreur, vous demandez l'accès à un tableau sur une variable qui n'est pas un tableau.");
             return -3001;
          }
          if (e1.t.t.construit.ptc != PTCArray)
             //messerr("Erreur, l'élément auquel vous voulez accédez n'est pas un tableau.");
             return -3002;
          }
          if (e2.t.nature != PTNBase)
          {
             //messerr("On ne peut accéder aux éléments d'un tableau qu'avec un type scalaire.");
             return -3003;
          }
          if (e2.t.t.base.ptb != PTBInteger)
             //messerr("tu essayes d'accèder à un élément de tableau avec un type non scalaire. DTC.");
             return -3004;
          }
          
          ptarray a = e1.t.t.construit.upcons.a;
          pvarray b = e1.val.a;
          pvinteger i = e2.val.n;
          if (a.min > i)
          {
             //messerr("L'indice est inférieur à la borne inférieur.");
             return -3005;
          }
          if (a.max < i)
          {
             //messerr("L'indice est supérieur à la borne supérieur.");
             return -3006;
          }
          
          // Enfin !
          val = b.tab[i - a.min];
          return 0;
          break;
          





     case PNot:
          VERIF_OK(this->expr.upnot.e->r_evaluate(env, e));
          
          switch (e.t) 
          {
                 case PBoolean: 
                      val.t = PBoolean;
                      val.val.b = !(e.val.b);
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un not, calcul du not d'une valeur non booléenne.");
                  return -31;
          }
          
          break;
          







     case PUPlus:
          VERIF_OK(this->expr.upuplus.e->r_evaluate(env, e));
          
          switch (e.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = e.val.i;
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = e.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un uplus, calcul du plus unaire sur un bool ou un real.");
                  return -32;
          }
          
          break;
          




     case PUMoins:
          VERIF_OK(this->expr.upumoins.e->r_evaluate(env, e));
          
          switch (e.t) 
          {
                 case PInteger: 
                      val.t = PInteger;
                      val.val.i = - e.val.i;
                      break;
                 case PReal:
                      val.t = PReal;
                      val.val.r = - e.val.r;
                      break;
                 default: 
                  //messerr("Erreur d'évaluation d'une expression d'un script. Lors d'un umoins, calcul du moins unaire sur un bool ou un real.");
                  return -33;
          }
          
          break;
          









     case PInd:
          VERIF_OK(this->expr.upind.e->r_evaluate(env, e));
          
          // Vérification que l'élément est de type pointeur.
          if (e.t.nature != PTNConstruit)
          {
             //messerr("Désolé, on ne peut faire des indirections que sur des pointeurs.");
             return -3101;
          }
          if (e.t.construit.ptc != PTCPointer)
          {
             //messerr("Il est impossible de faire des indirections sur auter chose que des pointeurs.");
             return -3102;
          }
          psval temp = mem[e.val.ptr];
          if (temp.pstype != PSValeur)
          {
             //messerr("Je ne sais pas faire d'indirection sur ce machin.");
             return -3103;
          }
          val = temp.v.val;
          return 0;
          break;
          









     case PRef:
          VERIF_OK(this->expr.upref.e->l_evaluate(env, val));
          return 0;
          break;
          









     case PIdent:
          int i = envlookup(env, this->expr.upident.pident);
          if (i < 0)
          {
             //messerr("Impossible d'évaluer l'expression car l'identifiant n'a pas trouvé dans la table des symboles.");
             return -34;
          }



          switch (env[i].t)
          {
                 case PDConstante:
                      val = env[i].contenu.c;
                      //val = env[i].contenu;
                      break;
                 case PDMemoire:
                      {
                       SMemCell xc = mem[env[i].contenu.m.adr];
                      
                      if (xc.t != PSValeur)
                      {
                         //messerr("les pointeurs sur les fonctions ne sont pas encore implémentés. Unpeu de patience je vous prie.");
                         return -135;
                      }
                      val = xc.v.val;
                      }
                      /*
                      val.t = PPointeur;
                      
                      val.val.ptr.lptype = env[i].contenu.m.pt;
                      val.val.ptr.ptr = .v;
                      */
                      break;









     case PConst:
          // En fait, ce qu'on a dans cette expression est directement une pval.
          // Elle est "constante".
          // Il suffit de la retourner.
          val = this->expr.upconst.pconst;
          return 0;
          break;








          default:
                  //messerr("Impossible d'évaluer l'expression, car elle a un type complétement inconnue.");
                  return -9999;
          }
     return 0;
}
















/* Renvoie un code d'erreur.
   0 oki
   négatif : dtc
   -1 : lors d'un ET, l'opérande de gauche n'était pas du type booléen ;
   -2 : lors d'un ET, l'opérande de droite n'était pas du type booléen ;
*/
/*
enum pascal_expression {PEt, POu, PEqual, PDiff, PInf, PSup, PInfEq, PSupEq, \
     PPlus, PMoins, PMult, PDiv, PMod, PNot, PUPlus, PUMoins, PIdent};
*/
int CPexpr::l_evaluate(PValeur &val)
{
    PValeur e, e1, e2;
    int ret;
    #define VERIF_OK(a) {if ((ret = (a)) < 0){return ret;}}
    
    switch(this->t)
    {
     case PEt:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Et sur une LValue n'a aucun sens.");
          return -10;
          break;
          
     case POu:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Ou sur une LValue n'a aucun sens.");
          return -20;
          break;

     case PEqual:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Equal sur une LValue n'a aucun sens.");
          return -30;
          break;

     case PDiff:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Equal sur une LValue n'a aucun sens.");
          return -40;
          break;

     case PInf:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Inf sur une LValue n'a aucun sens.");
          return -50;
          break;

     case PSup:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Sup sur une LValue n'a aucun sens.");
          return -60;
          break;

     case PInfEq:
          //messerr("Erreur de l_evaluation d'une expression. Une opération InfEq sur une LValue n'a aucun sens.");
          return -70;
          break;

     case PSupEq:
          //messerr("Erreur de l_evaluation d'une expression. Une opération SupEq sur une LValue n'a aucun sens.");
          return -80;
          break;

     case PPlus:
          //messerr("Erreur de l_evaluation d'une expression. Une opération + entre une adresse et un scalaire a un sens, mais ici on fait du Pascal, pas du C, que diable !!!");
          return -90;
          break;

     case PMoins:
          //messerr("Erreur de l_evaluation d'une expression. Une opération - entre une adresse et un scalaire a un sens, mais ici on fait du Pascal, pas du C, que diable !!!");
          return -100;
          break;

     case PMult:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Mult sur une LValue n'a aucun sens.");
          return -110;
          break;

     case PDiv:
          //messerr("Erreur de l_evaluation d'une expression. Une opération Div sur une LValue n'a aucun sens.");
          return -120;
          break;

     case PMod:
          //messerr("Erreur de l_evaluation d'une expression. Une opération modulo entre deux adresses a un sens, mais ici on fait du Pascal, pas du C, que diable !!!");
          return -130;
          break;

     case PNot:
          //messerr("Erreur de l_evaluation d'une expression. Une opération not sur une adresse a un sens, mais ici on fait du Pascal, pas du C, que diable !!!");
          return -140;
          break;

     case PUPlus:
          //messerr("Ecoute, tu m'expliques ce que tu veux faire avec Plus unaire et une adresse, après on dicute.");
          return -150;
          break;

     case PUMoins:
          //mess("Un moins unaire sur une adresse !!?? mais t'as trop fumé mon gars.");
          return -160;
          break;

     case PIdent:
          int i = envlookup(this->expr.upident.pident);

          if (i < 0)
          {
             //messerr("Impossible de L_évaluer l'expression car l'identifiant n'a pas trouvé dans la table des symboles.");
             return -170;
          }



          switch (env[i].t)
          {
                 case PDConstante:
                      //messerr("Mais enfin t'es con ou quoi ? C'est pas possible de prendre l'adresse d'une constante.");
                      return -171;
                      break;
                 case PDMemoire:
                      {
                       pam p = env[i].contenu.m.adr;
                       
                       val.t = PPointeur;
                       val.val.ptr.lptype = 
                       val.val.ptr.ptr = p;
                       SMemCell xc = mem[p];
                      
                      if (xc.t != PSValeur)
                      {
                         //messerr("les pointeurs sur les fonctions ne sont pas encore implémentés. Unpeu de patience je vous prie.");
                         return -135;
                      }
                      val = xc.v.val;
                      }
                      /*
                      val.t = PPointeur;
                      
                      val.val.ptr.lptype = env[i].contenu.m.pt;
                      val.val.ptr.ptr = .v;
                      */
                      break;
                 default:
                         //messerr("Type DVal inconnu dans Ident. (Erreur Interne)");
                         return -35;
          }
          break;

     }
     return 0;
}

































































